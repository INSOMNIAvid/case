<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro CS:GO Style Shooter - Dust2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Arial', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            background-color: #5d8aa8;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-family: 'Courier New', monospace;
        }
        
        .hud-panel {
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            padding: 8px 12px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #healthPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 220px;
        }
        
        #healthBar {
            width: 200px;
            height: 20px;
            background-color: rgba(70, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        
        #healthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #e74c3c, #f39c12);
            transition: width 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        #healthText {
            font-size: 18px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
            text-shadow: 1px 1px 2px black;
        }
        
        #ammoPanel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            min-width: 100px;
        }
        
        #ammoCount {
            font-size: 28px;
            font-weight: bold;
            color: #f1c40f;
            text-shadow: 1px 1px 2px black;
        }
        
        #ammoReserve {
            font-size: 16px;
            color: #95a5a6;
            text-shadow: 1px 1px 2px black;
        }
        
        #weaponInfo {
            position: absolute;
            bottom: 80px;
            right: 20px;
            font-size: 18px;
            color: #ecf0f1;
            text-shadow: 1px 1px 2px black;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 24px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        .crosshair-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            top: 10px;
            left: 10px;
            box-shadow: 0 0 3px black;
        }
        
        .crosshair-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 3px black;
        }
        
        #crosshair-h {
            width: 8px;
            height: 2px;
            top: 11px;
            left: 8px;
        }
        
        #crosshair-v {
            width: 2px;
            height: 8px;
            top: 8px;
            left: 11px;
        }
        
        #killFeed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 200px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .killEntry {
            margin-bottom: 5px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-left: 3px solid #e74c3c;
            font-size: 14px;
            animation: fadeOut 4s forwards;
            transform: translateX(100%);
            animation: slideIn 0.3s forwards, fadeOut 4s 3.7s forwards;
            text-shadow: 1px 1px 2px black;
        }
        
        @keyframes slideIn {
            to { transform: translateX(0); }
        }
        
        @keyframes fadeOut {
            to { opacity: 0; }
        }
        
        #scorePanel {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }
        
        #score {
            color: #f1c40f;
            font-weight: bold;
        }
        
        #enemiesLeft {
            color: #e74c3c;
            font-weight: bold;
        }
        
        #waveInfo {
            color: #3498db;
            font-weight: bold;
        }
        
        #gameMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #gameTitle {
            font-size: 48px;
            margin-bottom: 40px;
            color: #f1c40f;
            text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
        }
        
        .menu-button {
            background: linear-gradient(to bottom, #34495e, #2c3e50);
            border: none;
            color: white;
            padding: 15px 30px;
            margin: 10px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            min-width: 200px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            text-shadow: 1px 1px 2px black;
        }
        
        .menu-button:hover {
            background: linear-gradient(to bottom, #3d566e, #34495e);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        #controlsInfo {
            margin-top: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
            max-width: 500px;
            text-align: center;
            display: none;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-key {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        #gameOverMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #gameOverTitle {
            font-size: 48px;
            margin-bottom: 20px;
            color: #e74c3c;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            font-family: 'Impact', sans-serif;
        }
        
        #finalScore {
            font-size: 24px;
            margin-bottom: 30px;
            color: #f1c40f;
            text-align: center;
            line-height: 1.5;
        }
        
        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
        }
        
        #hitMarker::before, #hitMarker::after {
            content: "";
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 3px black;
        }
        
        #hitMarker::before {
            width: 4px;
            height: 20px;
            left: 13px;
            top: 5px;
        }
        
        #hitMarker::after {
            width: 20px;
            height: 4px;
            left: 5px;
            top: 13px;
        }
        
        .blood-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            transition: opacity 0.3s;
        }
        
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            z-index: 20;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px;
            color: white;
            font-size: 24px;
            user-select: none;
            touch-action: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #mobileShoot {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(231, 76, 60, 0.5);
        }
        
        #mobileJoystick {
            position: absolute;
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #mobileJoystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
            touch-action: none;
        }
        
        #reloadIndicator {
            position: absolute;
            bottom: 170px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            pointer-events: none;
        }
        
        #waveAlert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 5px;
            font-size: 24px;
            font-weight: bold;
            color: #f1c40f;
            text-align: center;
            display: none;
            pointer-events: none;
            z-index: 90;
            animation: pulse 1s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            <div id="miniMap"></div>
            
            <div id="scorePanel" class="hud-panel">
                Score: <span id="score">0</span> | Enemies: <span id="enemiesLeft">0</span> | Wave: <span id="waveInfo">1</span>
            </div>
            
            <div id="healthPanel" class="hud-panel">
                <div id="healthBar">
                    <div id="healthFill"></div>
                </div>
                <div id="healthText">100</div>
            </div>
            
            <div id="ammoPanel" class="hud-panel">
                <div id="ammoCount">30</div>
                <div id="ammoReserve">90</div>
            </div>
            
            <div id="weaponInfo" class="hud-panel">AK-47</div>
            
            <div id="crosshair">
                <div class="crosshair-dot"></div>
                <div class="crosshair-line" id="crosshair-h"></div>
                <div class="crosshair-line" id="crosshair-v"></div>
            </div>
            
            <div id="killFeed"></div>
            
            <div id="hitMarker"></div>
            <div class="blood-effect" id="bloodEffect"></div>
            
            <div id="reloadIndicator">RELOADING...</div>
            <div id="waveAlert">WAVE 1 INCOMING!</div>
        </div>
        
        <div id="mobileControls">
            <div id="mobileJoystick">
                <div id="mobileJoystickKnob"></div>
            </div>
            <div id="mobileShoot" class="mobile-btn">FIRE</div>
        </div>
        
        <div id="gameMenu">
            <h1 id="gameTitle">DUST2 SHOOTER</h1>
            <button class="menu-button" id="startButton">START GAME</button>
            <button class="menu-button" id="controlsButton">CONTROLS</button>
            
            <div id="controlsInfo">
                <h3>CONTROLS</h3>
                <div class="control-row">
                    <span>Movement:</span>
                    <span class="control-key">W/A/S/D</span>
                </div>
                <div class="control-row">
                    <span>Shoot:</span>
                    <span class="control-key">MOUSE LEFT</span>
                </div>
                <div class="control-row">
                    <span>Aim:</span>
                    <span class="control-key">MOUSE</span>
                </div>
                <div class="control-row">
                    <span>Switch Weapons:</span>
                    <span class="control-key">1/2/3</span>
                </div>
                <div class="control-row">
                    <span>Reload:</span>
                    <span class="control-key">R</span>
                </div>
                <button class="menu-button" id="backButton" style="margin-top: 15px; padding: 8px 20px; font-size: 16px;">BACK</button>
            </div>
        </div>
        
        <div id="gameOverMenu">
            <h1 id="gameOverTitle">GAME OVER</h1>
            <div id="finalScore">Score: 0<br>Kills: 0<br>Wave: 0</div>
            <button class="menu-button" id="restartButton">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Game constants
        const PLAYER_SPEED = 5.5;
        const BULLET_SPEED = 25;
        const ENEMY_SPEED = 2.2;
        const ENEMY_SPAWN_RATE = 1500; // ms
        const MAX_ENEMIES = 20;
        const MAP_WIDTH = 2500;
        const MAP_HEIGHT = 2500;
        const CELL_SIZE = 50;
        const WAVE_SIZE = 8;
        const WAVE_INCREASE = 3;
        
        // Game variables
        let canvas, ctx, miniMapCtx;
        let player = {
            x: 500,
            y: 500,
            width: 30,
            height: 50,
            angle: 0,
            health: 100,
            maxHealth: 100,
            score: 0,
            kills: 0,
            weapons: [
                { 
                    name: "Knife", 
                    damage: 35, 
                    ammo: Infinity, 
                    maxAmmo: Infinity, 
                    fireRate: 500, 
                    range: 50, 
                    isMelee: true,
                    color: "#95a5a6"
                },
                { 
                    name: "Glock-18", 
                    damage: 18, 
                    ammo: 20, 
                    maxAmmo: 120, 
                    fireRate: 200, 
                    range: 600,
                    bulletSpeed: 20,
                    color: "#3498db",
                    sound: "pistol"
                },
                { 
                    name: "AK-47", 
                    damage: 32, 
                    ammo: 30, 
                    maxAmmo: 90, 
                    fireRate: 100, 
                    range: 900,
                    bulletSpeed: 25,
                    color: "#e74c3c",
                    spread: 0.05,
                    sound: "rifle"
                }
            ],
            currentWeapon: 2,
            lastShot: 0,
            isReloading: false
        };
        
        let bullets = [];
        let enemies = [];
        let lastEnemySpawn = 0;
        let mouseX = 0, mouseY = 0;
        let keys = {};
        let camera = { x: 0, y: 0 };
        let map = [];
        let killFeed = [];
        let gameTime = 0;
        let wave = 1;
        let enemiesInWave = 0;
        let gameStarted = false;
        let gameOver = false;
        let isMobile = false;
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickPower = 0;
        
        // Sound effects (would be implemented with Web Audio API)
        const sounds = {
            pistol: { rate: 1.0 },
            rifle: { rate: 1.0 },
            reload: { rate: 1.0 },
            hit: { rate: 1.0 },
            death: { rate: 1.0 }
        };
        
        // Dust2 map layout (improved)
        function generateDust2Map() {
            // Create empty map
            const cols = Math.floor(MAP_WIDTH / CELL_SIZE);
            const rows = Math.floor(MAP_HEIGHT / CELL_SIZE);
            map = Array(rows).fill().map(() => Array(cols).fill(0));
            
            // Middle boxes (B site)
            for (let i = 10; i < 16; i++) {
                for (let j = 15; j < 21; j++) {
                    if (i === 12 || i === 13) continue; // Leave gap in middle
                    map[i][j] = 1;
                }
            }
            
            // A site walls
            for (let i = 5; i < 11; i++) {
                map[i][5] = 1;
                map[i][10] = 1;
                if (i > 6 && i < 9) {
                    map[i][7] = 1;
                    map[i][8] = 1;
                }
            }
            
            // B site walls
            for (let i = 25; i < 31; i++) {
                map[i][30] = 1;
                map[i][35] = 1;
                if (i > 27 && i < 29) {
                    map[i][32] = 1;
                    map[i][33] = 1;
                }
            }
            
            // Long A
            for (let j = 5; j < 16; j++) {
                map[5][j] = 1;
                map[15][j] = 1;
                if (j > 7 && j < 13) {
                    map[10][j] = 1;
                }
            }
            
            // Mid doors
            for (let i = 18; i < 23; i++) {
                map[i][20] = 1;
            }
            
            // Tunnels
            for (let j = 25; j < 31; j++) {
                map[10][j] = 1;
                map[20][j] = 1;
            }
            
            // CT Spawn
            for (let i = 2; i < 6; i++) {
                for (let j = 2; j < 6; j++) {
                    map[i][j] = 2; // Different texture for spawn
                }
            }
            
            // T Spawn
            for (let i = 35; i < 39; i++) {
                for (let j = 35; j < 39; j++) {
                    map[i][j] = 2;
                }
            }
            
            // Bombsite A
            for (let i = 7; i < 9; i++) {
                for (let j = 6; j < 9; j++) {
                    map[i][j] = 3; // Bombsite texture
                }
            }
            
            // Bombsite B
            for (let i = 27; i < 29; i++) {
                for (let j = 31; j < 34; j++) {
                    map[i][j] = 3; // Bombsite texture
                }
            }
        }
        
        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            const miniMap = document.getElementById('miniMap');
            miniMapCtx = miniMap.getContext('2d');
            
            // Check if mobile device
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                document.getElementById('mobileControls').style.display = 'block';
                setupMobileControls();
            }
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Generate map
            generateDust2Map();
            renderMiniMap();
            
            // Setup event listeners
            setupEventListeners();
            
            // Setup menu buttons
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', startGame);
            document.getElementById('controlsButton').addEventListener('click', showControls);
            document.getElementById('backButton').addEventListener('click', hideControls);
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        function setupMobileControls() {
            const joystick = document.getElementById('mobileJoystickKnob');
            const joystickArea = document.getElementById('mobileJoystick');
            const shootBtn = document.getElementById('mobileShoot');
            
            let touchId = null;
            let joystickStartX = 0;
            let joystickStartY = 0;
            
            joystickArea.addEventListener('touchstart', (e) => {
                if (touchId !== null) return;
                
                const touch = e.touches[0];
                touchId = touch.identifier;
                const rect = joystickArea.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
                
                updateJoystick(touch.clientX, touch.clientY);
                joystickActive = true;
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (touchId === null) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === touchId) {
                        updateJoystick(e.touches[i].clientX, e.touches[i].clientY);
                        e.preventDefault();
                        return;
                    }
                }
            });
            
            document.addEventListener('touchend', (e) => {
                if (touchId === null) return;
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        resetJoystick();
                        e.preventDefault();
                        return;
                    }
                }
            });
            
            shootBtn.addEventListener('touchstart', (e) => {
                if (!gameStarted || gameOver) return;
                
                const weapon = player.weapons[player.currentWeapon];
                if (Date.now() - player.lastShot > weapon.fireRate) {
                    shoot();
                    player.lastShot = Date.now();
                }
                e.preventDefault();
            });
            
            function updateJoystick(x, y) {
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = rect.width / 2;
                
                joystickAngle = Math.atan2(dy, dx);
                joystickPower = Math.min(distance / maxDistance, 1);
                
                // Position joystick knob
                const knobX = centerX + dx * 0.5 - rect.left;
                const knobY = centerY + dy * 0.5 - rect.top;
                joystick.style.transform = `translate(${knobX - 20}px, ${knobY - 20}px)`;
            }
            
            function resetJoystick() {
                joystickActive = false;
                joystickPower = 0;
                joystick.style.transform = 'translate(30px, 30px)';
                touchId = null;
            }
        }
        
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Mouse events
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleMouseClick);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            
            // Prevent right-click menu
            document.addEventListener('contextmenu', (e) => {
                if (gameStarted) e.preventDefault();
            });
        }
        
        function handleTouchStart(e) {
            if (!gameStarted || gameOver) return;
            
            const weapon = player.weapons[player.currentWeapon];
            if (Date.now() - player.lastShot > weapon.fireRate) {
                shoot();
                player.lastShot = Date.now();
            }
            e.preventDefault();
        }
        
        function handleTouchMove(e) {
            if (!gameStarted || gameOver) return;
            
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
            e.preventDefault();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            // Weapon switching
            if (e.key >= '1' && e.key <= '3') {
                const weaponIndex = parseInt(e.key) - 1;
                if (weaponIndex < player.weapons.length) {
                    player.currentWeapon = weaponIndex;
                    updateWeaponInfo();
                }
            }
            
            // Reload with R key
            if (e.key.toLowerCase() === 'r' && !player.isReloading) {
                reloadWeapon();
            }
            
            // Pause game with ESC
            if (e.key === 'Escape' && gameStarted && !gameOver) {
                togglePause();
            }
        }
        
        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }
        
        function handleMouseMove(e) {
            if (!gameStarted || gameOver) return;
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        }
        
        function handleMouseClick(e) {
            if (!gameStarted || gameOver) return;
            
            if (e.button === 0 && Date.now() - player.lastShot > player.weapons[player.currentWeapon].fireRate) {
                shoot();
                player.lastShot = Date.now();
            }
        }
        
        function togglePause() {
            const menu = document.getElementById('gameMenu');
            if (menu.style.display === 'flex') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'flex';
                document.getElementById('startButton').textContent = 'RESUME GAME';
                document.getElementById('controlsInfo').style.display = 'none';
            }
        }
        
        function shoot() {
            const weapon = player.weapons[player.currentWeapon];
            
            if (weapon.ammo <= 0 && !player.isReloading) {
                reloadWeapon();
                return;
            }
            
            if (weapon.ammo <= 0) return;
            
            // Reduce ammo
            if (weapon.ammo !== Infinity) {
                weapon.ammo--;
                updateAmmoInfo();
            }
            
            // Play shoot sound (would be implemented with Web Audio API)
            if (weapon.sound) {
                // playSound(weapon.sound);
            }
            
            if (weapon.isMelee) {
                // Melee attack
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < weapon.range) {
                        enemy.health -= weapon.damage;
                        showHitMarker();
                        // playSound('hit');
                        
                        if (enemy.health <= 0) {
                            addKill(`You killed Enemy with ${weapon.name}`);
                            // playSound('death');
                            enemies.splice(i, 1);
                            i--;
                        } else {
                            // Show blood effect
                            showBloodEffect();
                        }
                    }
                }
            } else {
                // Ranged attack
                const angle = player.angle;
                
                // Add weapon spread
                let bulletAngle = angle;
                if (weapon.spread) {
                    bulletAngle += (Math.random() - 0.5) * weapon.spread;
                }
                
                bullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(bulletAngle) * (weapon.bulletSpeed || BULLET_SPEED),
                    dy: Math.sin(bulletAngle) * (weapon.bulletSpeed || BULLET_SPEED),
                    damage: weapon.damage,
                    range: weapon.range,
                    distance: 0,
                    color: weapon.color || '#f1c40f',
                    size: weapon.name === 'Glock-18' ? 2 : 3
                });
            }
        }
        
        function reloadWeapon() {
            const weapon = player.weapons[player.currentWeapon];
            
            if (weapon.ammo === weapon.maxAmmo || weapon.ammo === Infinity) return;
            
            player.isReloading = true;
            document.getElementById('reloadIndicator').style.display = 'block';
            
            // Play reload sound (would be implemented with Web Audio API)
            // playSound('reload');
            
            // Simulate reload time
            setTimeout(() => {
                const ammoNeeded = weapon.maxAmmo - weapon.ammo;
                weapon.ammo = weapon.maxAmmo;
                updateAmmoInfo();
                player.isReloading = false;
                document.getElementById('reloadIndicator').style.display = 'none';
                
                // Add to kill feed
                addKillFeed(`Reloaded ${weapon.name}`);
            }, 1500); // 1.5 second reload time
        }
        
        function updatePlayer(deltaTime) {
            // Calculate movement direction from keyboard or joystick
            let moveX = 0, moveY = 0;
            
            if (joystickActive) {
                // Mobile joystick control
                moveX = Math.cos(joystickAngle) * joystickPower;
                moveY = Math.sin(joystickAngle) * joystickPower;
            } else {
                // Keyboard control
                if (keys['w'] || keys['arrowup']) moveY -= 1;
                if (keys['s'] || keys['arrowdown']) moveY += 1;
                if (keys['a'] || keys['arrowleft']) moveX -= 1;
                if (keys['d'] || keys['arrowright']) moveX += 1;
            }
            
            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071; // 1/sqrt(2)
                moveY *= 0.7071;
            }
            
            // Calculate new position
            const newX = player.x + moveX * PLAYER_SPEED * deltaTime;
            const newY = player.y + moveY * PLAYER_SPEED * deltaTime;
            
            // Check collision with walls
            if (!checkWallCollision(newX, player.y)) {
                player.x = newX;
            }
            if (!checkWallCollision(player.x, newY)) {
                player.y = newY;
            }
            
            // Keep player within map bounds
            player.x = Math.max(player.width/2, Math.min(MAP_WIDTH - player.width/2, player.x));
            player.y = Math.max(player.height/2, Math.min(MAP_HEIGHT - player.height/2, player.y));
            
            // Update player angle based on mouse position
            if (!isMobile) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const relX = mouseX - centerX;
                const relY = mouseY - centerY;
                player.angle = Math.atan2(relY, relX);
            } else if (enemies.length > 0) {
                // Auto-aim slightly toward nearest enemy on mobile
                let nearestEnemy = null;
                let minDist = Infinity;
                
                for (const enemy of enemies) {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = dx*dx + dy*dy;
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearestEnemy = enemy;
                    }
                }
                
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - player.x;
                    const dy = nearestEnemy.y - player.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    // Smoothly adjust angle toward enemy
                    const angleDiff = ((targetAngle - player.angle + Math.PI) % (Math.PI*2)) - Math.PI;
                    player.angle += angleDiff * 0.1 * deltaTime;
                }
            }
            
            // Update camera to follow player
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            
            // Keep camera within map bounds
            camera.x = Math.max(0, Math.min(MAP_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(MAP_HEIGHT - canvas.height, camera.y));
        }
        
        function checkWallCollision(x, y) {
            // Convert world coordinates to map cells
            const cellX = Math.floor(x / CELL_SIZE);
            const cellY = Math.floor(y / CELL_SIZE);
            
            // Check if out of bounds
            if (cellX < 0 || cellY < 0 || cellX >= map[0].length || cellY >= map.length) {
                return true;
            }
            
            // Check if wall exists at this cell
            return map[cellY][cellX] === 1;
        }
        
        function updateBullets(deltaTime) {
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                
                // Update position
                bullet.x += bullet.dx * deltaTime;
                bullet.y += bullet.dy * deltaTime;
                bullet.distance += (bullet.dx * deltaTime) ** 2 + (bullet.dy * deltaTime) ** 2;
                
                // Check if bullet hit a wall
                if (checkWallCollision(bullet.x, bullet.y)) {
                    // Create bullet hole effect (would be added with graphics)
                    bullets.splice(i, 1);
                    i--;
                    continue;
                }
                
                // Check if bullet is out of range
                if (bullet.distance > bullet.range * bullet.range) {
                    bullets.splice(i, 1);
                    i--;
                    continue;
                }
                
                // Check for enemy hits
                for (let j = 0; j < enemies.length; j++) {
                    const enemy = enemies[j];
                    const dx = enemy.x - bullet.x;
                    const dy = enemy.y - bullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.width / 2) {
                        enemy.health -= bullet.damage;
                        bullets.splice(i, 1);
                        i--;
                        
                        // Show hit marker
                        showHitMarker();
                        // playSound('hit');
                        
                        if (enemy.health <= 0) {
                            addKill(`You killed Enemy with ${player.weapons[player.currentWeapon].name}`);
                            // playSound('death');
                            player.kills++;
                            player.score += 100 * wave;
                            enemies.splice(j, 1);
                            enemiesInWave--;
                            updateScore();
                            
                            // Check if wave is complete
                            if (enemiesInWave <= 0 && enemies.length === 0) {
                                nextWave();
                            }
                        } else {
                            // Show blood effect
                            showBloodEffect();
                        }
                        
                        break;
                    }
                }
            }
        }
        
        function spawnWave() {
            enemiesInWave = WAVE_SIZE + (wave - 1) * WAVE_INCREASE;
            showWaveAlert(`WAVE ${wave} - ${enemiesInWave} ENEMIES INCOMING!`);
            lastEnemySpawn = 0; // Reset spawn timer
        }
        
        function nextWave() {
            wave++;
            spawnWave();
            player.health = Math.min(player.maxHealth, player.health + 20); // Heal between waves
            updateHealthBar();
        }
        
        function showWaveAlert(message) {
            const waveAlert = document.getElementById('waveAlert');
            waveAlert.textContent = message;
            waveAlert.style.display = 'block';
            
            setTimeout(() => {
                waveAlert.style.display = 'none';
            }, 2000);
        }
        
        function spawnEnemies(deltaTime) {
            if (!gameStarted || gameOver) return;
            
            lastEnemySpawn += deltaTime;
            
            if (lastEnemySpawn > ENEMY_SPAWN_RATE && enemies.length < MAX_ENEMIES && enemiesInWave > 0) {
                let x, y;
                let attempts = 0;
                const maxAttempts = 10;
                
                // Find a spawn position far from player
                do {
                    if (Math.random() > 0.5) {
                        // Spawn from edges
                        if (Math.random() > 0.5) {
                            x = Math.random() > 0.5 ? 50 : MAP_WIDTH - 50;
                            y = Math.random() * MAP_HEIGHT;
                        } else {
                            x = Math.random() * MAP_WIDTH;
                            y = Math.random() > 0.5 ? 50 : MAP_HEIGHT - 50;
                        }
                    } else {
                        // Spawn randomly but far from player
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 400 + Math.random() * 300;
                        x = player.x + Math.cos(angle) * distance;
                        y = player.y + Math.sin(angle) * distance;
                    }
                    
                    attempts++;
                    if (attempts >= maxAttempts) break;
                } while (Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2)) < 400 || 
                       checkWallCollision(x, y));
                
                if (attempts < maxAttempts) {
                    enemies.push({
                        x: x,
                        y: y,
                        width: 30,
                        height: 50,
                        health: 80 + wave * 10,
                        maxHealth: 80 + wave * 10,
                        speed: ENEMY_SPEED + wave * 0.1,
                        damage: 10 + wave * 2
                    });
                    
                    enemiesInWave--;
                    lastEnemySpawn = 0;
                }
            }
        }
        
        function updateEnemies(deltaTime) {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // Simple AI: move toward player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 150) { // Only move if far away
                    const angle = Math.atan2(dy, dx);
                    const newX = enemy.x + Math.cos(angle) * enemy.speed * deltaTime;
                    const newY = enemy.y + Math.sin(angle) * enemy.speed * deltaTime;
                    
                    // Check wall collision for new position
                    if (!checkWallCollision(newX, enemy.y)) {
                        enemy.x = newX;
                    }
                    if (!checkWallCollision(enemy.x, newY)) {
                        enemy.y = newY;
                    }
                }
                
                // Check if enemy hits player
                if (distance < player.width / 2 + enemy.width / 2) {
                    player.health -= enemy.damage * deltaTime / 1000; // Convert to per second
                    updateHealthBar();
                    
                    // Show blood effect when taking damage
                    if (Math.random() > 0.9) {
                        showBloodEffect();
                    }
                    
                    if (player.health <= 0) {
                        player.health = 0;
                        gameOver = true;
                        showGameOver();
                    }
                }
            }
        }
        
        function updateHealthBar() {
            const healthFill = document.getElementById('healthFill');
            const healthText = document.getElementById('healthText');
            
            const healthPercent = (player.health / player.maxHealth) * 100;
            healthFill.style.width = `${healthPercent}%`;
            healthText.textContent = Math.floor(player.health);
            
            // Change color based on health
            if (player.health < 30) {
                healthFill.style.background = '#e74c3c';
                healthFill.style.animation = 'pulse 0.5s infinite alternate';
            } else if (player.health < 60) {
                healthFill.style.background = 'linear-gradient(to right, #e74c3c, #f39c12)';
                healthFill.style.animation = 'none';
            } else {
                healthFill.style.background = 'linear-gradient(to right, #f39c12, #2ecc71)';
                healthFill.style.animation = 'none';
            }
        }
        
        function updateAmmoInfo() {
            const weapon = player.weapons[player.currentWeapon];
            document.getElementById('ammoCount').textContent = weapon.ammo;
            document.getElementById('ammoReserve').textContent = weapon.maxAmmo;
            
            // Flash ammo count when low
            if (weapon.ammo < weapon.maxAmmo * 0.3 && weapon.ammo !== Infinity) {
                document.getElementById('ammoCount').style.animation = 'pulse 0.5s infinite alternate';
            } else {
                document.getElementById('ammoCount').style.animation = 'none';
            }
        }
        
        function updateWeaponInfo() {
            document.getElementById('weaponInfo').textContent = 
                player.weapons[player.currentWeapon].name;
            updateAmmoInfo();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = player.score;
            document.getElementById('enemiesLeft').textContent = enemies.length;
            document.getElementById('waveInfo').textContent = wave;
        }
        
        function addKill(message) {
            const killFeed = document.getElementById('killFeed');
            const entry = document.createElement('div');
            entry.className = 'killEntry';
            entry.textContent = message;
            killFeed.insertBefore(entry, killFeed.firstChild);
            
            // Remove old entries
            if (killFeed.children.length > 5) {
                killFeed.removeChild(killFeed.lastChild);
            }
        }
        
        function addKillFeed(message) {
            const killFeed = document.getElementById('killFeed');
            const entry = document.createElement('div');
            entry.className = 'killEntry';
            entry.textContent = message;
            killFeed.insertBefore(entry, killFeed.firstChild);
            
            // Remove old entries
            if (killFeed.children.length > 8) {
                killFeed.removeChild(killFeed.lastChild);
            }
        }
        
        function showHitMarker() {
            const hitMarker = document.getElementById('hitMarker');
            hitMarker.style.opacity = '1';
            
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 200);
        }
        
        function showBloodEffect() {
            const bloodEffect = document.getElementById('bloodEffect');
            bloodEffect.style.opacity = '0.7';
            
            setTimeout(() => {
                bloodEffect.style.opacity = '0';
            }, 300);
        }
        
        function renderMiniMap() {
            const miniMap = document.getElementById('miniMap');
            const cellSize = miniMap.width / (MAP_WIDTH / CELL_SIZE);
            
            miniMapCtx.clearRect(0, 0, miniMap.width, miniMap.height);
            
            // Draw map
            for (let row = 0; row < map.length; row++) {
                for (let col = 0; col < map[row].length; col++) {
                    if (map[row][col] === 1) {
                        miniMapCtx.fillStyle = '#8B4513'; // Walls
                        miniMapCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    } else if (map[row][col] === 2) {
                        miniMapCtx.fillStyle = '#34495e'; // Spawns
                        miniMapCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    } else if (map[row][col] === 3) {
                        miniMapCtx.fillStyle = '#f1c40f'; // Bombsites
                        miniMapCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }
        }
        
        function updateMiniMap() {
            const miniMap = document.getElementById('miniMap');
            const cellSize = miniMap.width / (MAP_WIDTH / CELL_SIZE);
            
            // Clear previous player and enemies
            miniMapCtx.clearRect(0, 0, miniMap.width, miniMap.height);
            
            // Redraw map (simplified)
            miniMapCtx.fillStyle = '#b5a642'; // Floor color
            miniMapCtx.fillRect(0, 0, miniMap.width, miniMap.height);
            
            // Draw walls
            miniMapCtx.fillStyle = '#8B4513';
            for (let row = 0; row < map.length; row++) {
                for (let col = 0; col < map[row].length; col++) {
                    if (map[row][col] === 1) {
                        miniMapCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    } else if (map[row][col] === 2) {
                        miniMapCtx.fillStyle = '#34495e';
                        miniMapCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                        miniMapCtx.fillStyle = '#8B4513';
                    } else if (map[row][col] === 3) {
                        miniMapCtx.fillStyle = '#f1c40f';
                        miniMapCtx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                        miniMapCtx.fillStyle = '#8B4513';
                    }
                }
            }
            
            // Draw player
            const playerX = player.x / MAP_WIDTH * miniMap.width;
            const playerY = player.y / MAP_HEIGHT * miniMap.height;
            miniMapCtx.fillStyle = '#3498db';
            miniMapCtx.beginPath();
            miniMapCtx.arc(playerX, playerY, 4, 0, Math.PI * 2);
            miniMapCtx.fill();
            
            // Draw player direction
            miniMapCtx.strokeStyle = '#3498db';
            miniMapCtx.lineWidth = 2;
            miniMapCtx.beginPath();
            miniMapCtx.moveTo(playerX, playerY);
            miniMapCtx.lineTo(
                playerX + Math.cos(player.angle) * 10,
                playerY + Math.sin(player.angle) * 10
            );
            miniMapCtx.stroke();
            
            // Draw enemies
            miniMapCtx.fillStyle = '#e74c3c';
            for (const enemy of enemies) {
                const enemyX = enemy.x / MAP_WIDTH * miniMap.width;
                const enemyY = enemy.y / MAP_HEIGHT * miniMap.height;
                miniMapCtx.beginPath();
                miniMapCtx.arc(enemyX, enemyY, 3, 0, Math.PI * 2);
                miniMapCtx.fill();
            }
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw map (with camera offset)
            const startCol = Math.max(0, Math.floor(camera.x / CELL_SIZE));
            const startRow = Math.max(0, Math.floor(camera.y / CELL_SIZE));
            const endCol = Math.min(map[0].length, Math.ceil((camera.x + canvas.width) / CELL_SIZE));
            const endRow = Math.min(map.length, Math.ceil((camera.y + canvas.height) / CELL_SIZE));
            
            for (let row = startRow; row < endRow; row++) {
                for (let col = startCol; col < endCol; col++) {
                    const x = col * CELL_SIZE - camera.x;
                    const y = row * CELL_SIZE - camera.y;
                    
                    if (map[row][col] === 1) {
                        // Draw wall with improved texture
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        
                        // Add brick pattern
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < CELL_SIZE; i += 10) {
                            ctx.beginPath();
                            ctx.moveTo(x, y + i);
                            ctx.lineTo(x + CELL_SIZE, y + i);
                            ctx.stroke();
                            
                            if (i % 20 === 0) {
                                ctx.beginPath();
                                ctx.moveTo(x + i, y);
                                ctx.lineTo(x + i, y + CELL_SIZE);
                                ctx.stroke();
                            }
                        }
                    } else if (map[row][col] === 2) {
                        // Spawn areas
                        ctx.fillStyle = '#34495e';
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        
                        // Grid pattern
                        ctx.strokeStyle = '#2c3e50';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < CELL_SIZE; i += 10) {
                            ctx.beginPath();
                            ctx.moveTo(x, y + i);
                            ctx.lineTo(x + CELL_SIZE, y + i);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(x + i, y);
                            ctx.lineTo(x + i, y + CELL_SIZE);
                            ctx.stroke();
                        }
                    } else if (map[row][col] === 3) {
                        // Bombsite
                        ctx.fillStyle = '#b5a642';
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        
                        // Bombsite marker
                        ctx.fillStyle = '#f1c40f';
                        ctx.beginPath();
                        ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#e67e22';
                        ctx.beginPath();
                        ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/4, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Draw floor with improved texture
                        ctx.fillStyle = '#b5a642';
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        
                        // Add subtle noise
                        for (let i = 0; i < 5; i++) {
                            const nx = x + Math.random() * CELL_SIZE;
                            const ny = y + Math.random() * CELL_SIZE;
                            const size = Math.random() * 3;
                            ctx.fillStyle = `rgba(200, 180, 100, ${Math.random() * 0.3})`;
                            ctx.fillRect(nx, ny, size, size);
                        }
                    }
                }
            }
            
            // Draw enemies with improved graphics
            for (const enemy of enemies) {
                const x = enemy.x - camera.x - enemy.width / 2;
                const y = enemy.y - camera.y - enemy.height / 2;
                
                // Body
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(x, y, enemy.width, enemy.height);
                
                // Head
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(x + 5, y - 10, enemy.width - 10, 10);
                
                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(x, y - 15, enemy.width, 5);
                
                // Health bar
                const healthWidth = enemy.width * (enemy.health / enemy.maxHealth);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(x, y - 15, healthWidth, 5);
                
                // Enemy shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(
                    x + enemy.width/2, 
                    y + enemy.height, 
                    enemy.width/2, 
                    enemy.width/4, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Draw bullets with trail effect
            for (const bullet of bullets) {
                const x = bullet.x - camera.x;
                const y = bullet.y - camera.y;
                
                // Bullet trail
                ctx.strokeStyle = `${bullet.color}80`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - bullet.dx * 0.2, y - bullet.dy * 0.2);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Bullet head
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(x, y, bullet.size || 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw player with improved graphics
            const playerX = player.x - camera.x - player.width / 2;
            const playerY = player.y - camera.y - player.height / 2;
            
            // Player shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                playerX + player.width/2, 
                playerY + player.height, 
                player.width/2, 
                player.width/4, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Body
            ctx.fillStyle = '#3498db';
            ctx.fillRect(playerX, playerY, player.width, player.height);
            
            // Head
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(playerX + 5, playerY - 10, player.width - 10, 10);
            
            // Draw weapon
            const weapon = player.weapons[player.currentWeapon];
            if (!weapon.isMelee) {
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(
                    playerX + player.width / 2 - 5, 
                    playerY + player.height - 10, 
                    30, 
                    5
                );
                
                // Weapon barrel
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(
                    playerX + player.width / 2 + 25, 
                    playerY + player.height - 8, 
                    15, 
                    2
                );
            } else {
                // Draw knife
                ctx.fillStyle = '#95a5a6';
                ctx.beginPath();
                ctx.moveTo(playerX + player.width / 2 + 10, playerY + player.height - 5);
                ctx.lineTo(playerX + player.width / 2 + 30, playerY + player.height - 15);
                ctx.lineTo(playerX + player.width / 2 + 25, playerY + player.height - 10);
                ctx.closePath();
                ctx.fill();
            }
            
            // Update minimap
            updateMiniMap();
        }
        
        function startGame() {
            // Reset game state
            player = {
                x: 500,
                y: 500,
                width: 30,
                height: 50,
                angle: 0,
                health: 100,
                maxHealth: 100,
                score: 0,
                kills: 0,
                weapons: [
                    { 
                        name: "Knife", 
                        damage: 35, 
                        ammo: Infinity, 
                        maxAmmo: Infinity, 
                        fireRate: 500, 
                        range: 50, 
                        isMelee: true,
                        color: "#95a5a6"
                    },
                    { 
                        name: "Glock-18", 
                        damage: 18, 
                        ammo: 20, 
                        maxAmmo: 120, 
                        fireRate: 200, 
                        range: 600,
                        bulletSpeed: 20,
                        color: "#3498db",
                        sound: "pistol"
                    },
                    { 
                        name: "AK-47", 
                        damage: 32, 
                        ammo: 30, 
                        maxAmmo: 90, 
                        fireRate: 100, 
                        range: 900,
                        bulletSpeed: 25,
                        color: "#e74c3c",
                        spread: 0.05,
                        sound: "rifle"
                    }
                ],
                currentWeapon: 2,
                lastShot: 0,
                isReloading: false
            };
            
            bullets = [];
            enemies = [];
            wave = 1;
            enemiesInWave = 0;
            gameTime = 0;
            gameOver = false;
            gameStarted = true;
            
            // Clear kill feed
            document.getElementById('killFeed').innerHTML = '';
            
            // Update UI
            updateHealthBar();
            updateWeaponInfo();
            updateScore();
            
            // Spawn first wave
            spawnWave();
            
            // Hide menus
            document.getElementById('gameMenu').style.display = 'none';
            document.getElementById('gameOverMenu').style.display = 'none';
            document.getElementById('controlsInfo').style.display = 'none';
        }
        
        function showControls() {
            document.getElementById('controlsInfo').style.display = 'block';
        }
        
        function hideControls() {
            document.getElementById('controlsInfo').style.display = 'none';
        }
        
        function showGameOver() {
            document.getElementById('gameOverMenu').style.display = 'flex';
            document.getElementById('finalScore').innerHTML = 
                `Score: ${player.score}<br>Kills: ${player.kills}<br>Wave: ${wave-1}`;
        }
        
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = Math.min(timestamp - lastTime, 100); // Cap delta time to prevent physics issues
            lastTime = timestamp;
            
            if (gameStarted && !gameOver) {
                gameTime += deltaTime;
                updatePlayer(deltaTime);
                updateBullets(deltaTime);
                spawnEnemies(deltaTime);
                updateEnemies(deltaTime);
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game when page loads
        window.onload = init;
    </script>
</body>
</html>