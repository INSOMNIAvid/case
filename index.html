<!DOCTYPE html>
<html>
<head>
    <title>3D Tactical Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            color: white;
            background: #000;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            transition: all 0.1s;
        }
        
        #crosshair-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            border: 2px solid rgba(255, 0, 0, 0.7);
            transition: all 0.05s;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        #crosshair-outer {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        #hit-marker::before, #hit-marker::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 50, 50, 0.8);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        
        #hit-marker::before {
            top: 0;
            left: 50%;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }
        
        #hit-marker::after {
            left: 0;
            top: 50%;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }
        
        #health-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #ff9900, #00ff00);
            transition: width 0.3s;
        }
        
        #ammo {
            position: absolute;
            bottom: 60px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        #mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            z-index: 50;
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 100%;
            position: relative;
            transition: all 0.5s;
        }
        
        .map-player {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        
        .map-enemy {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        
        .map-object {
            position: absolute;
            background: rgba(200, 200, 200, 0.7);
            transform-origin: center;
        }
        
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #menu h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #ff5555;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        .menu-btn {
            padding: 12px 24px;
            font-size: 1.2em;
            background: linear-gradient(to bottom, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            min-width: 200px;
            transition: all 0.3s;
        }
        
        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }
        
        #settings {
            display: none;
            margin-top: 20px;
            text-align: center;
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        #loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #loading-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }
        
        #bullet-holes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .bullet-hole {
            position: absolute;
            width: 10px;
            height: 10px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="black"/><circle cx="12" cy="12" r="6" fill="%23333"/></svg>') no-repeat center;
            background-size: contain;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>Загрузка игры...</h1>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
    </div>

    <div id="ui">
        <div>Управление: WASD - движение, SPACE - прыжок, SHIFT - бег, ЛКМ - стрельба, R - перезарядка, M - карта</div>
    </div>
    <div id="crosshair">
        <div id="crosshair-outer"></div>
        <div id="crosshair-inner"></div>
    </div>
    <div id="hit-marker"></div>
    <div id="bullet-holes"></div>
    <div id="health-bar"><div id="health-fill"></div></div>
    <div id="ammo">30/120</div>
    <div id="score">0 очков</div>
    <div id="mini-map">
        <div id="map"></div>
    </div>

    <div id="menu">
        <h1>TACTICAL SHOOTER</h1>
        <button id="startBtn" class="menu-btn">Одиночная игра</button>
        <button id="settingsBtn" class="menu-btn">Настройки</button>
        <div id="settings">
            <div style="margin: 10px;">
                <label for="volume">Громкость: </label>
                <input type="range" id="volume" min="0" max="1" step="0.1" value="0.5">
            </div>
            <div style="margin: 10px;">
                <label for="sensitivity">Чувствительность мыши: </label>
                <input type="range" id="sensitivity" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div style="margin: 10px;">
                <label for="graphics">Качество графики: </label>
                <select id="graphics">
                    <option value="low">Низкое</option>
                    <option value="medium" selected>Среднее</option>
                    <option value="high">Высокое</option>
                </select>
            </div>
            <button id="backBtn" class="menu-btn" style="background: linear-gradient(to bottom, #555555, #333333);">Назад</button>
        </div>
    </div>

    <!-- Three.js и дополнительные библиотеки -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Конфигурация игры
        const config = {
            graphics: {
                quality: 'medium',
                bloom: {
                    strength: 1.5,
                    radius: 0.4,
                    threshold: 0.85
                }
            },
            player: {
                speed: {
                    walk: 4,
                    run: 8
                },
                jumpForce: 8,
                height: 1.8,
                radius: 0.5
            },
            world: {
                gravity: -9.8 * 2,
                size: 200,
                mapSize: 300
            },
            weapons: [
                { 
                    name: "Пистолет", 
                    damage: 25, 
                    fireRate: 0.2, 
                    ammo: 15, 
                    maxAmmo: 60, 
                    reloadTime: 1.5, 
                    model: "pistol.glb", 
                    sound: "pistol.mp3", 
                    bulletSpeed: 100, 
                    bulletSize: 0.05, 
                    bulletColor: 0xffff00,
                    recoil: 0.1
                },
                { 
                    name: "Автомат", 
                    damage: 15, 
                    fireRate: 0.1, 
                    ammo: 30, 
                    maxAmmo: 120, 
                    reloadTime: 2.5, 
                    model: "rifle.glb", 
                    sound: "rifle.mp3", 
                    bulletSpeed: 120, 
                    bulletSize: 0.03, 
                    bulletColor: 0x00ffff,
                    recoil: 0.05
                }
            ],
            enemies: {
                types: [
                    { 
                        name: "Солдат", 
                        health: 50, 
                        speed: 1.5, 
                        damage: 10, 
                        score: 10,
                        color: 0xff0000
                    },
                    { 
                        name: "Разведчик", 
                        health: 30, 
                        speed: 3.0, 
                        damage: 5, 
                        score: 20,
                        color: 0x00ff00
                    }
                ],
                spawnRate: 3,
                maxCount: 15
            },
            bonuses: [
                { type: 'health', name: "Аптечка", amount: 25, color: 0x00ff00 },
                { type: 'ammo', name: "Патроны", amount: 30, color: 0xffff00 }
            ]
        };

        // Основные переменные игры
        let scene, camera, renderer, controls, world;
        let composer, bloomPass, outlinePass, fxaaPass;
        let enemies = [], bonuses = [], destructibles = [], weapons = [], bullets = [];
        let currentWeaponIndex = 0, score = 0, health = 100, maxHealth = 100;
        let ammo = 0, maxAmmo = 0, isGameRunning = false;
        let playerBody, playerModel, clock = new THREE.Clock(), lastEnemySpawn = 0;
        let playerVelocity = new THREE.Vector3(), playerDirection = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isRunning = false, isReloading = false, lastShot = 0;
        let mouseSensitivity = 1, volume = 0.5, abilityCooldown = false;
        let abilityCooldownTimer = 0, abilityCooldownTime = 10;
        let mixer, currentAnimation, muzzleFlash, hitMarkerTimeout;
        let mapObjects = [], mapScale = 1, isMapOpen = false;

        // Звуки
        const sounds = {
            shoot: [
                new Howl({ src: ['https://assets.codepen.io/21542/howler-gun-shot.mp3'], volume: 0.7 }),
                new Howl({ src: ['https://assets.codepen.io/21542/howler-gun-shot-2.mp3'], volume: 0.7 })
            ],
            hit: new Howl({ src: ['https://assets.codepen.io/21542/howler-hit.mp3'], volume: 0.5 }),
            death: new Howl({ src: ['https://assets.codepen.io/21542/howler-death.mp3'], volume: 0.5 }),
            reload: new Howl({ src: ['https://assets.codepen.io/21542/howler-reload.mp3'], volume: 0.5 }),
            pickup: new Howl({ src: ['https://assets.codepen.io/21542/howler-pickup.mp3'], volume: 0.5 }),
            jump: new Howl({ src: ['https://assets.codepen.io/21542/howler-jump.mp3'], volume: 0.3 }),
            hurt: new Howl({ src: ['https://assets.codepen.io/21542/howler-hurt.mp3'], volume: 0.5 }),
            weapon_switch: new Howl({ src: ['https://assets.codepen.io/21542/howler-weapon-switch.mp3'], volume: 0.3 })
        };

        // Инициализация игры
        function init() {
            // Сцена
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);

            // Камера
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = config.player.height;

            // Рендерер
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // Post-processing
            initPostProcessing();

            // Физический мир
            world = new CANNON.World();
            world.gravity.set(0, config.world.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Управление
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // Освещение
            setupLighting();

            // Создание мира
            createWorld();

            // Загрузка оружия
            loadWeapons(() => {
                // После загрузки оружия скрываем экран загрузки
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('menu').style.display = 'flex';
                
                // Обновляем UI
                ammo = weapons[currentWeaponIndex].ammo;
                maxAmmo = weapons[currentWeaponIndex].maxAmmo;
                updateUI();
            });

            // Создание эффекта дульного вспышки
            createMuzzleFlash();

            // Слушатели событий
            setupEventListeners();
        }

        // Инициализация post-processing
        function initPostProcessing() {
            const renderScene = new THREE.RenderPass(scene, camera);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                config.graphics.bloom.strength,
                config.graphics.bloom.radius,
                config.graphics.bloom.threshold
            );
            
            outlinePass = new THREE.OutlinePass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                scene,
                camera
            );
            outlinePass.edgeStrength = 3.0;
            outlinePass.edgeGlow = 0.5;
            outlinePass.edgeThickness = 1.0;
            outlinePass.pulsePeriod = 0;
            
            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outlinePass);
            composer.addPass(fxaaPass);
        }

        // Настройка освещения
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
            scene.add(ambientLight);

            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Hemisphere light
            const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(hemisphereLight);

            // Point lights
            const pointLight1 = new THREE.PointLight(0xffaa00, 0.5, 20);
            pointLight1.position.set(5, 5, 5);
            pointLight1.castShadow = true;
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00aaff, 0.5, 20);
            pointLight2.position.set(-5, 5, -5);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
        }

        // Создание игрового мира
        function createWorld() {
            // Пол (земля)
            const groundGeometry = new THREE.PlaneGeometry(config.world.size, config.world.size);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5f0b,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Физическое тело для земли
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // Физическое тело игрока
            const playerShape = new CANNON.Sphere(config.player.radius);
            playerBody = new CANNON.Body({ mass: 5 });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, config.player.height, 0);
            playerBody.linearDamping = 0.5;
            world.addBody(playerBody);

            // Создание карты
            createMap();

            // Создание укрытий
            createCovers();

            // Создание разрушаемых объектов
            createDestructibles();

            // Создание бонусов
            createBonuses(5);
        }

        // Создание карты
        function createMap() {
            // Центральное здание
            const buildingGeometry = new THREE.BoxGeometry(20, 10, 20);
            const buildingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.3
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(0, 5, 0);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);

            // Физическое тело здания
            const buildingShape = new CANNON.Box(new CANNON.Vec3(10, 5, 10));
            const buildingBody = new CANNON.Body({ mass: 0 });
            buildingBody.addShape(buildingShape);
            buildingBody.position.copy(building.position);
            world.addBody(buildingBody);

            // Добавляем объект на карту
            addToMap(building.position, 20, 20, 'building');

            // Стены по периметру
            const wallPositions = [
                { x: 0, z: -50, width: 100, height: 5, depth: 2 },
                { x: 0, z: 50, width: 100, height: 5, depth: 2 },
                { x: -50, z: 0, width: 2, height: 5, depth: 100 },
                { x: 50, z: 0, width: 2, height: 5, depth: 100 }
            ];

            wallPositions.forEach(pos => {
                const wallGeometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x555555,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(pos.x, pos.height/2, pos.z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);

                // Физическое тело стены
                const wallShape = new CANNON.Box(new CANNON.Vec3(pos.width/2, pos.height/2, pos.depth/2));
                const wallBody = new CANNON.Body({ mass: 0 });
                wallBody.addShape(wallShape);
                wallBody.position.copy(wall.position);
                world.addBody(wallBody);

                // Добавляем стену на карту
                addToMap(wall.position, pos.width, pos.depth, 'wall');
            });

            // Несколько бочек
            for (let i = 0; i < 10; i++) {
                const barrelGeometry = new THREE.CylinderGeometry(1, 1, 2, 16);
                const barrelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 30;
                barrel.position.set(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                scene.add(barrel);

                // Физическое тело бочки
                const barrelShape = new CANNON.Cylinder(1, 1, 2, 16);
                const barrelBody = new CANNON.Body({ mass: 5 });
                barrelBody.addShape(barrelShape);
                barrelBody.position.copy(barrel.position);
                barrelBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                world.addBody(barrelBody);

                // Добавляем бочку на карту
                addToMap(barrel.position, 2, 2, 'barrel');
            }

            // Определяем масштаб карты
            mapScale = 150 / config.world.size;
        }

        // Добавление объекта на карту
        function addToMap(position, width, depth, type) {
            const map = document.getElementById('map');
            const element = document.createElement('div');
            element.className = 'map-object';
            
            // Позиционируем элемент на карте
            const x = position.x * mapScale + 75;
            const z = position.z * mapScale + 75;
            
            element.style.left = `${x}px`;
            element.style.top = `${z}px`;
            
            // Размеры элемента
            const elementWidth = width * mapScale;
            const elementDepth = depth * mapScale;
            
            element.style.width = `${elementWidth}px`;
            element.style.height = `${elementDepth}px`;
            
            // Стили в зависимости от типа объекта
            switch(type) {
                case 'building':
                    element.style.backgroundColor = 'rgba(100, 100, 100, 0.8)';
                    element.style.border = '1px solid #555';
                    break;
                case 'wall':
                    element.style.backgroundColor = 'rgba(150, 150, 150, 0.7)';
                    element.style.border = '1px solid #777';
                    break;
                case 'barrel':
                    element.style.width = `${elementWidth}px`;
                    element.style.height = `${elementDepth}px`;
                    element.style.borderRadius = '50%';
                    element.style.backgroundColor = 'rgba(139, 69, 19, 0.7)';
                    element.style.border = '1px solid #8B4513';
                    break;
            }
            
            map.appendChild(element);
            mapObjects.push({ element, position, width, depth, type });
        }

        // Обновление мини-карты
        function updateMiniMap() {
            const map = document.getElementById('map');
            const playerMarker = document.querySelector('.map-player');
            const enemyMarkers = document.querySelectorAll('.map-enemy');
            
            // Удаляем старые маркеры
            if (playerMarker) playerMarker.remove();
            enemyMarkers.forEach(marker => marker.remove());
            
            // Добавляем маркер игрока
            const playerElement = document.createElement('div');
            playerElement.className = 'map-player';
            
            const playerX = playerBody.position.x * mapScale + 75;
            const playerZ = playerBody.position.z * mapScale + 75;
            
            playerElement.style.left = `${playerX}px`;
            playerElement.style.top = `${playerZ}px`;
            
            map.appendChild(playerElement);
            
            // Добавляем маркеры врагов
            enemies.forEach(enemy => {
                const enemyElement = document.createElement('div');
                enemyElement.className = 'map-enemy';
                
                const enemyX = enemy.body.position.x * mapScale + 75;
                const enemyZ = enemy.body.position.z * mapScale + 75;
                
                enemyElement.style.left = `${enemyX}px`;
                enemyElement.style.top = `${enemyZ}px`;
                
                map.appendChild(enemyElement);
            });
            
            // Центрируем карту на игроке
            map.style.transform = `translate(${75 - playerX}px, ${75 - playerZ}px)`;
        }

        // Создание укрытий
        function createCovers() {
            const coverPositions = [
                { x: 15, z: 15, width: 3, depth: 1, height: 1.5 },
                { x: -15, z: 15, width: 2, depth: 4, height: 1.2 },
                { x: 15, z: -15, width: 5, depth: 1, height: 1.8 },
                { x: -15, z: -15, width: 1, depth: 3, height: 1.3 }
            ];

            coverPositions.forEach(pos => {
                const geometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, pos.height/2, pos.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Физическое тело укрытия
                const shape = new CANNON.Box(new CANNON.Vec3(pos.width/2, pos.height/2, pos.depth/2));
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.copy(mesh.position);
                world.addBody(body);

                // Добавляем на карту
                addToMap(mesh.position, pos.width, pos.depth, 'cover');
            });
        }

        // Создание разрушаемых объектов
        function createDestructibles() {
            const destructiblePositions = [
                { x: 10, z: 10, size: 1.2 },
                { x: -10, z: 10, size: 0.8 },
                { x: 15, z: -15, size: 1.5 },
                { x: -15, z: -15, size: 1.0 }
            ];

            destructiblePositions.forEach(pos => {
                const geometry = new THREE.BoxGeometry(pos.size, pos.size, pos.size);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xC0C0C0,
                    roughness: 0.5,
                    metalness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, pos.size/2, pos.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Физическое тело объекта
                const shape = new CANNON.Box(new CANNON.Vec3(pos.size/2, pos.size/2, pos.size/2));
                const body = new CANNON.Body({ mass: 5 });
                body.addShape(shape);
                body.position.copy(mesh.position);
                world.addBody(body);

                destructibles.push({ 
                    mesh, 
                    body,
                    health: 100,
                    size: pos.size
                });

                // Добавляем на карту
                addToMap(mesh.position, pos.size, pos.size, 'destructible');
            });
        }

        // Создание бонусов
        function createBonuses(count) {
            for (let i = 0; i < count; i++) {
                const type = Math.floor(Math.random() * config.bonuses.length);
                const bonusType = config.bonuses[type];
                const size = 0.5;
                
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: bonusType.color,
                    roughness: 0.2,
                    metalness: 0.8,
                    emissive: bonusType.color,
                    emissiveIntensity: 0.5
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.x = (Math.random() - 0.5) * 40;
                mesh.position.z = (Math.random() - 0.5) * 40;
                mesh.position.y = size;
                mesh.castShadow = true;
                
                // Физическое тело бонуса
                const shape = new CANNON.Sphere(size);
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.copy(mesh.position);
                
                scene.add(mesh);
                world.addBody(body);
                
                bonuses.push({
                    mesh,
                    body,
                    type: bonusType
                });

                // Добавляем на карту
                addToMap(mesh.position, 1, 1, 'bonus');
            }
        }

        // Загрузка оружия
        function loadWeapons(callback) {
            const loader = new THREE.GLTFLoader();
            let loadedCount = 0;
            
            // Показываем прогресс загрузки
            const updateProgress = () => {
                loadedCount++;
                const progress = (loadedCount / config.weapons.length) * 100;
                document.getElementById('loading-progress').style.width = `${progress}%`;
            };
            
            config.weapons.forEach((weapon, index) => {
                // В реальном проекте здесь должна быть загрузка модели
                // Для примера создаем простые модели
                
                const geometry = new THREE.BoxGeometry(0.3, 0.2, 0.8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const model = new THREE.Mesh(geometry, material);
                model.position.set(0.5, -0.3, -0.8);
                model.rotation.set(0, Math.PI, 0);
                model.visible = (index === 0);
                
                // Добавляем оружие в массив
                weapons.push({
                    model,
                    type: weapon,
                    ammo: weapon.ammo,
                    maxAmmo: weapon.maxAmmo
                });
                
                // Добавляем модель к камере
                camera.add(model);
                
                updateProgress();
                
                // Если все оружие загружено, вызываем callback
                if (loadedCount === config.weapons.length && callback) {
                    callback();
                }
            });
        }

        // Создание эффекта дульного вспышки
        function createMuzzleFlash() {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff9900,
                transparent: true,
                opacity: 0
            });
            muzzleFlash = new THREE.Mesh(geometry, material);
            muzzleFlash.position.set(0.5, -0.3, -1.2);
            camera.add(muzzleFlash);
        }

        // Анимация дульного вспышки
        function animateMuzzleFlash() {
            if (!muzzleFlash) return;
            
            muzzleFlash.material.opacity = 1;
            muzzleFlash.scale.set(1, 1, 1);
            
            let scale = 1;
            const animate = () => {
                scale += 0.2;
                muzzleFlash.scale.set(scale, scale, scale);
                muzzleFlash.material.opacity = 1 - (scale - 1) / 3;
                
                if (scale >= 4) {
                    muzzleFlash.material.opacity = 0;
                    return;
                }
                
                requestAnimationFrame(animate);
            };
            
            animate();
        }

        // Создание следа от пули
        function createBulletHole(position, normal) {
            const bulletHole = document.createElement('div');
            bulletHole.className = 'bullet-hole';
            
            // Позиционируем след от пули
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const bulletHole = document.createElement('div');
                bulletHole.className = 'bullet-hole';
                
                // Вычисляем позицию на экране
                const vector = intersect.point.clone();
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                
                bulletHole.style.left = `${x}px`;
                bulletHole.style.top = `${y}px`;
                
                document.getElementById('bullet-holes').appendChild(bulletHole);
                
                // Удаляем через 10 секунд
                setTimeout(() => {
                    if (bulletHole.parentNode) {
                        bulletHole.parentNode.removeChild(bulletHole);
                    }
                }, 10000);
            }
        }

        // Переключение оружия
        function switchWeapon(index) {
            if (index < 0 || index >= weapons.length || index === currentWeaponIndex) return;
            
            // Скрываем текущее оружие
            weapons[currentWeaponIndex].model.visible = false;
            
            // Показываем новое оружие
            currentWeaponIndex = index;
            weapons[currentWeaponIndex].model.visible = true;
            
            // Обновляем UI
            ammo = weapons[currentWeaponIndex].ammo;
            maxAmmo = weapons[currentWeaponIndex].maxAmmo;
            fireRate = weapons[currentWeaponIndex].type.fireRate;
            updateUI();
            
            // Проигрываем звук смены оружия
            sounds.weapon_switch.play();
        }

        // Перезарядка
        function reload() {
            if (isReloading || maxAmmo <= 0 || weapons[currentWeaponIndex].ammo === weapons[currentWeaponIndex].type.ammo) return;
            
            isReloading = true;
            sounds.reload.play();
            
            setTimeout(() => {
                const weapon = weapons[currentWeaponIndex];
                const needed = weapon.type.ammo - weapon.ammo;
                const available = Math.min(needed, maxAmmo);
                weapon.ammo += available;
                maxAmmo -= available;
                ammo = weapon.ammo;
                isReloading = false;
                updateUI();
            }, weapons[currentWeaponIndex].type.reloadTime * 1000);
        }

        // Обработка клика (стрельба)
        function onClick() {
            if (!isGameRunning) {
                controls.lock();
                return;
            }
            
            if (!controls.isLocked || isReloading || isMapOpen) return;
            
            const now = clock.getElapsedTime();
            if (now - lastShot < fireRate || weapons[currentWeaponIndex].ammo <= 0) return;
            
            lastShot = now;
            weapons[currentWeaponIndex].ammo--;
            ammo = weapons[currentWeaponIndex].ammo;
            updateUI();
            
            // Анимация прицела при выстреле
            animateCrosshair();
            
            // Проиграть звук выстрела
            const shootSound = sounds.shoot[Math.floor(Math.random() * sounds.shoot.length)];
            shootSound.play();
            
            // Анимация отдачи
            weapons[currentWeaponIndex].model.position.z += 0.1;
            setTimeout(() => { 
                weapons[currentWeaponIndex].model.position.z -= 0.1; 
            }, 100);
            
            // Анимация дульного вспышки
            animateMuzzleFlash();
            
            // Raycasting для попадания
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects([...enemies.map(e => e.mesh), ...destructibles.map(d => d.mesh)]);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                // Создаем след от пули
                createBulletHole(intersect.point, intersect.face.normal);
                
                // Проверка попадания во врагов
                const enemy = enemies.find(e => e.mesh === intersect.object);
                if (enemy) {
                    enemy.health -= weapons[currentWeaponIndex].type.damage;
                    sounds.hit.play();
                    showHitMarker();
                    
                    if (enemy.health <= 0) {
                        score += enemy.score;
                        scene.remove(enemy.mesh);
                        world.removeBody(enemy.body);
                        enemies = enemies.filter(e => e !== enemy);
                        
                        // Обновляем карту
                        updateMiniMap();
                    }
                }
                
                // Проверка попадания в разрушаемые объекты
                const obj = destructibles.find(d => d.mesh === intersect.object);
                if (obj) {
                    obj.health -= weapons[currentWeaponIndex].type.damage;
                    sounds.hit.play();
                    
                    if (obj.health <= 0) {
                        scene.remove(obj.mesh);
                        world.removeBody(obj.body);
                        destructibles = destructibles.filter(d => d !== obj);
                        
                        // Обновляем карту
                        updateMiniMap();
                    }
                }
            }
        }

        // Анимация прицела при выстреле
        function animateCrosshair() {
            const inner = document.getElementById('crosshair-inner');
            const outer = document.getElementById('crosshair-outer');
            
            inner.style.transform = 'translate(-50%, -50%) scale(0.5)';
            outer.style.transform = 'translate(-50%, -50%) scale(1.2)';
            
            setTimeout(() => {
                inner.style.transform = 'translate(-50%, -50%) scale(1)';
                outer.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 100);
        }

        // Показать маркер попадания
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            
            if (hitMarkerTimeout) clearTimeout(hitMarkerTimeout);
            
            hitMarkerTimeout = setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 200);
        }

        // Обновление UI
        function updateUI() {
            document.getElementById('score').textContent = `${score} очков`;
            document.getElementById('health-fill').style.width = `${(health / maxHealth) * 100}%`;
            document.getElementById('ammo').textContent = `${ammo}/${maxAmmo}`;
        }

        // Проверка столкновений
        function checkCollisions() {
            // Столкновение игрока с врагами
            enemies.forEach(enemy => {
                const distance = playerBody.position.distanceTo(enemy.body.position);
                if (distance < config.player.radius + 0.5) {
                    health -= enemy.damage * 0.1;
                    sounds.hurt.play();
                    
                    if (health <= 0) {
                        gameOver();
                    }
                }
            });
            
            // Столкновение игрока с бонусами
            bonuses.forEach((bonus, index) => {
                const distance = playerBody.position.distanceTo(bonus.body.position);
                if (distance < config.player.radius + 0.5) {
                    switch (bonus.type.type) {
                        case 'health':
                            health = Math.min(maxHealth, health + bonus.type.amount);
                            break;
                        case 'ammo':
                            maxAmmo += bonus.type.amount;
                            break;
                    }
                    
                    sounds.pickup.play();
                    scene.remove(bonus.mesh);
                    world.removeBody(bonus.body);
                    bonuses.splice(index, 1);
                    updateUI();
                    
                    // Обновляем карту
                    updateMiniMap();
                }
            });
        }

        // Создание врагов
        function createEnemies(count) {
            for (let i = 0; i < count; i++) {
                const type = Math.floor(Math.random() * config.enemies.types.length);
                const enemyType = config.enemies.types[type];
                
                const size = 0.5 + Math.random() * 0.3;
                const geometry = new THREE.BoxGeometry(size, size, size);
                const material = new THREE.MeshStandardMaterial({ 
                    color: enemyType.color,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 30;
                mesh.position.x = Math.cos(angle) * distance;
                mesh.position.z = Math.sin(angle) * distance;
                mesh.position.y = size / 2;
                mesh.castShadow = true;
                
                // Физическое тело врага
                const shape = new CANNON.Sphere(size * 0.5);
                const body = new CANNON.Body({ mass: 1 });
                body.addShape(shape);
                body.position.copy(mesh.position);
                
                scene.add(mesh);
                world.addBody(body);
                
                enemies.push({
                    mesh,
                    body,
                    type: enemyType,
                    health: enemyType.health,
                    speed: enemyType.speed,
                    damage: enemyType.damage,
                    score: enemyType.score
                });
            }
            
            // Обновляем карту
            updateMiniMap();
        }

        // Конец игры
        function gameOver() {
            isGameRunning = false;
            sounds.death.play();
            controls.unlock();
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('startBtn').textContent = 'Заново';
        }

        // Начать игру
        function startGame() {
            // Очистка предыдущего состояния
            enemies.forEach(enemy => {
                scene.remove(enemy.mesh);
                world.removeBody(enemy.body);
            });
            bonuses.forEach(bonus => {
                scene.remove(bonus.mesh);
                world.removeBody(bonus.body);
            });
            destructibles.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            
            enemies = [];
            bonuses = [];
            score = 0;
            health = maxHealth;
            ammo = weapons[currentWeaponIndex].ammo;
            maxAmmo = weapons[currentWeaponIndex].maxAmmo;
            isGameRunning = true;
            lastEnemySpawn = 0;

            // Сброс позиции игрока
            playerBody.position.set(0, config.player.height, 0);
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);

            // Показать UI
            document.getElementById('menu').style.display = 'none';
            controls.lock();

            // Создать начальных врагов и бонусы
            createEnemies(5);
            createBonuses(3);
            createDestructibles();

            // Обновить UI
            updateUI();
            updateMiniMap();
        }

        // Переключение карты
        function toggleMap() {
            isMapOpen = !isMapOpen;
            const miniMap = document.getElementById('mini-map');
            
            if (isMapOpen) {
                miniMap.style.width = '300px';
                miniMap.style.height = '300px';
                miniMap.style.bottom = '50%';
                miniMap.style.right = '50%';
                miniMap.style.transform = 'translate(50%, 50%)';
                controls.unlock();
            } else {
                miniMap.style.width = '150px';
                miniMap.style.height = '150px';
                miniMap.style.bottom = '20px';
                miniMap.style.right = '20px';
                miniMap.style.transform = 'none';
                controls.lock();
            }
        }

        // Обработка нажатия клавиш
        function onKeyDown(event) {
            if (isMapOpen && event.code !== 'KeyM') return;
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { playerBody.velocity.y = config.player.jumpForce; canJump = false; sounds.jump.play(); } break;
                case 'ShiftLeft': isRunning = true; break;
                case 'KeyR': reload(); break;
                case 'Digit1': switchWeapon(0); break;
                case 'Digit2': switchWeapon(1); break;
                case 'KeyM': toggleMap(); break;
            }
        }

        // Обработка отпускания клавиш
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; break;
            }
        }

        // Обработка ресайза окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        }

        // Настройка слушателей событий
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onClick);
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('settingsBtn').addEventListener('click', showSettings);
            document.getElementById('backBtn').addEventListener('click', hideSettings);
            document.getElementById('volume').addEventListener('input', updateVolume);
            document.getElementById('sensitivity').addEventListener('input', updateSensitivity);
            document.getElementById('graphics').addEventListener('change', updateGraphics);
            window.addEventListener('resize', onWindowResize);
        }

        // Показать настройки
        function showSettings() {
            document.getElementById('settings').style.display = 'block';
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'none';
        }

        // Скрыть настройки
        function hideSettings() {
            document.getElementById('settings').style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('settingsBtn').style.display = 'block';
        }

        // Обновить громкость
        function updateVolume() {
            volume = parseFloat(document.getElementById('volume').value);
            Howler.volume(volume);
        }

        // Обновить чувствительность
        function updateSensitivity() {
            mouseSensitivity = parseFloat(document.getElementById('sensitivity').value);
        }

        // Обновить качество графики
        function updateGraphics() {
            config.graphics.quality = document.getElementById('graphics').value;
            
            switch(config.graphics.quality) {
                case 'low':
                    renderer.shadowMap.enabled = false;
                    bloomPass.strength = 0.5;
                    renderer.toneMapping = THREE.NoToneMapping;
                    break;
                case 'medium':
                    renderer.shadowMap.enabled = true;
                    bloomPass.strength = 1.0;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.0;
                    break;
                case 'high':
                    renderer.shadowMap.enabled = true;
                    bloomPass.strength = 1.5;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.2;
                    break;
            }
        }

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (controls.isLocked && isGameRunning) {
                // Движение игрока
                const velocity = playerBody.velocity;
                const frontVector = new THREE.Vector3(0, 0, -1).applyQuaternion(controls.getObject().quaternion);
                const sideVector = new THREE.Vector3(-1, 0, 0).applyQuaternion(controls.getObject().quaternion);
                
                playerDirection.set(0, 0, 0);
                
                if (moveForward) playerDirection.add(frontVector);
                if (moveBackward) playerDirection.sub(frontVector);
                if (moveLeft) playerDirection.add(sideVector);
                if (moveRight) playerDirection.sub(sideVector);
                
                playerDirection.normalize();
                const speed = isRunning ? config.player.speed.run : config.player.speed.walk;
                playerDirection.multiplyScalar(speed);
                
                velocity.x = playerDirection.x;
                velocity.z = playerDirection.z;
                
                // Проверка на земле ли игрок
                canJump = playerBody.position.y < config.player.height + 0.1;
                
                // Синхронизация позиции камеры с физическим телом
                controls.getObject().position.copy(playerBody.position);
                
                // Движение врагов к игроку
                enemies.forEach(enemy => {
                    const direction = new CANNON.Vec3();
                    direction.copy(playerBody.position);
                    direction.vsub(enemy.body.position, direction);
                    direction.normalize();
                    direction.scale(enemy.speed, direction);
                    direction.y = enemy.body.velocity.y;
                    enemy.body.velocity.copy(direction);
                    
                    // Поворот меша врага в сторону игрока
                    enemy.mesh.lookAt(
                        playerBody.position.x,
                        enemy.mesh.position.y,
                        playerBody.position.z
                    );
                });
                
                // Проверка столкновений
                checkCollisions();
                
                // Бесконечная генерация врагов
                const time = clock.getElapsedTime();
                if (time - lastEnemySpawn > enemySpawnInterval && enemies.length < config.enemies.maxCount) {
                    createEnemies(1);
                    lastEnemySpawn = time;
                    enemySpawnInterval = config.enemies.spawnRate;
                }
                
                // Обновление карты
                if (!isMapOpen) {
                    updateMiniMap();
                }
            }
            
            // Обновление физики
            world.step(1/60, delta, 3);
            
            // Рендеринг с post-processing
            if (config.graphics.quality !== 'low') {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Запуск игры
        init();
        animate();
    </script>
</body>
</html>