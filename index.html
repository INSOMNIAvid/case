<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS:GO Style Shooter - Dust2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            font-family: Arial, sans-serif;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            background-color: #7a9bb1;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #healthBar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
        }
        
        #healthFill {
            height: 100%;
            width: 100%;
            background-color: #e74c3c;
            transition: width 0.3s;
        }
        
        #ammoInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        
        #weaponInfo {
            position: absolute;
            bottom: 60px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            background-color: white;
        }
        
        #crosshair::before {
            width: 2px;
            height: 10px;
            left: 9px;
            top: 5px;
        }
        
        #crosshair::after {
            width: 10px;
            height: 2px;
            left: 5px;
            top: 9px;
        }
        
        #killFeed {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 16px;
            text-align: right;
        }
        
        .killEntry {
            margin-bottom: 5px;
            padding: 3px 8px;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeOut 3s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div id="ammoInfo">30 / 90</div>
            <div id="weaponInfo">AK-47</div>
            <div id="crosshair"></div>
            <div id="killFeed"></div>
        </div>
    </div>

    <script>
        // Game constants
        const PLAYER_SPEED = 5;
        const BULLET_SPEED = 20;
        const ENEMY_SPEED = 2;
        const MAP_WIDTH = 2000;
        const MAP_HEIGHT = 2000;
        const CELL_SIZE = 50;
        
        // Game variables
        let canvas, ctx;
        let player = {
            x: 500,
            y: 500,
            width: 30,
            height: 50,
            angle: 0,
            health: 100,
            weapons: [
                { name: "Knife", damage: 25, ammo: Infinity, maxAmmo: Infinity, fireRate: 500, range: 40, isMelee: true },
                { name: "Glock", damage: 15, ammo: 20, maxAmmo: 120, fireRate: 200, range: 500 },
                { name: "AK-47", damage: 30, ammo: 30, maxAmmo: 90, fireRate: 100, range: 800 }
            ],
            currentWeapon: 2,
            lastShot: 0
        };
        
        let bullets = [];
        let enemies = [];
        let lastEnemySpawn = 0;
        let mouseX = 0, mouseY = 0;
        let keys = {};
        let camera = { x: 0, y: 0 };
        let map = [];
        let killFeed = [];
        
        // Dust2 map layout (simplified)
        function generateDust2Map() {
            // Create empty map
            const cols = Math.floor(MAP_WIDTH / CELL_SIZE);
            const rows = Math.floor(MAP_HEIGHT / CELL_SIZE);
            map = Array(rows).fill().map(() => Array(cols).fill(0));
            
            // Define some walls (1 = wall, 0 = empty)
            // Middle boxes
            for (let i = 10; i < 15; i++) {
                for (let j = 15; j < 20; j++) {
                    map[i][j] = 1;
                }
            }
            
            // A site walls
            for (let i = 5; i < 10; i++) {
                map[i][5] = 1;
                map[i][10] = 1;
            }
            
            // B site walls
            for (let i = 25; i < 30; i++) {
                map[i][30] = 1;
                map[i][35] = 1;
            }
            
            // Long A
            for (let j = 5; j < 15; j++) {
                map[5][j] = 1;
                map[15][j] = 1;
            }
            
            // Mid doors
            map[20][20] = 1;
            map[21][20] = 1;
        }
        
        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Generate map
            generateDust2Map();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleMouseClick);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            // Weapon switching
            if (e.key >= '1' && e.key <= '3') {
                const weaponIndex = parseInt(e.key) - 1;
                if (weaponIndex < player.weapons.length) {
                    player.currentWeapon = weaponIndex;
                    updateWeaponInfo();
                }
            }
        }
        
        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }
        
        function handleMouseMove(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        }
        
        function handleMouseClick(e) {
            if (Date.now() - player.lastShot > player.weapons[player.currentWeapon].fireRate) {
                shoot();
                player.lastShot = Date.now();
            }
        }
        
        function shoot() {
            const weapon = player.weapons[player.currentWeapon];
            
            if (weapon.ammo <= 0) return;
            if (weapon.ammo !== Infinity) weapon.ammo--;
            updateAmmoInfo();
            
            if (weapon.isMelee) {
                // Melee attack
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < weapon.range) {
                        enemy.health -= weapon.damage;
                        if (enemy.health <= 0) {
                            addKillFeed(`You killed Enemy with ${weapon.name}`);
                            enemies.splice(i, 1);
                            i--;
                        }
                    }
                }
            } else {
                // Ranged attack
                const angle = player.angle;
                bullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(angle) * BULLET_SPEED,
                    dy: Math.sin(angle) * BULLET_SPEED,
                    damage: weapon.damage,
                    range: weapon.range,
                    distance: 0
                });
            }
        }
        
        function updatePlayer(deltaTime) {
            // Calculate movement direction
            let moveX = 0, moveY = 0;
            
            if (keys['w'] || keys['arrowup']) moveY -= 1;
            if (keys['s'] || keys['arrowdown']) moveY += 1;
            if (keys['a'] || keys['arrowleft']) moveX -= 1;
            if (keys['d'] || keys['arrowright']) moveX += 1;
            
            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071; // 1/sqrt(2)
                moveY *= 0.7071;
            }
            
            // Calculate new position
            const newX = player.x + moveX * PLAYER_SPEED * deltaTime;
            const newY = player.y + moveY * PLAYER_SPEED * deltaTime;
            
            // Check collision with walls
            if (!checkWallCollision(newX, player.y)) {
                player.x = newX;
            }
            if (!checkWallCollision(player.x, newY)) {
                player.y = newY;
            }
            
            // Update player angle based on mouse position
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const relX = mouseX - centerX;
            const relY = mouseY - centerY;
            player.angle = Math.atan2(relY, relX);
            
            // Update camera to follow player
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
        }
        
        function checkWallCollision(x, y) {
            // Convert world coordinates to map cells
            const cellX = Math.floor(x / CELL_SIZE);
            const cellY = Math.floor(y / CELL_SIZE);
            
            // Check if out of bounds
            if (cellX < 0 || cellY < 0 || cellX >= map[0].length || cellY >= map.length) {
                return true;
            }
            
            // Check if wall exists at this cell
            return map[cellY][cellX] === 1;
        }
        
        function updateBullets(deltaTime) {
            for (let i = 0; i < bullets.length; i++) {
                const bullet = bullets[i];
                
                // Update position
                bullet.x += bullet.dx * deltaTime;
                bullet.y += bullet.dy * deltaTime;
                bullet.distance += BULLET_SPEED * deltaTime;
                
                // Check if bullet hit a wall
                if (checkWallCollision(bullet.x, bullet.y)) {
                    bullets.splice(i, 1);
                    i--;
                    continue;
                }
                
                // Check if bullet is out of range
                if (bullet.distance > bullet.range) {
                    bullets.splice(i, 1);
                    i--;
                    continue;
                }
                
                // Check for enemy hits
                for (let j = 0; j < enemies.length; j++) {
                    const enemy = enemies[j];
                    const dx = enemy.x - bullet.x;
                    const dy = enemy.y - bullet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.width / 2) {
                        enemy.health -= bullet.damage;
                        bullets.splice(i, 1);
                        i--;
                        
                        if (enemy.health <= 0) {
                            addKillFeed(`You killed Enemy with ${player.weapons[player.currentWeapon].name}`);
                            enemies.splice(j, 1);
                        }
                        
                        break;
                    }
                }
            }
        }
        
        function spawnEnemies(deltaTime) {
            lastEnemySpawn += deltaTime;
            
            if (lastEnemySpawn > 2000 && enemies.length < 10) { // Spawn every 2 seconds, max 10 enemies
                let x, y;
                
                // Find a spawn position far from player
                do {
                    x = Math.random() * MAP_WIDTH;
                    y = Math.random() * MAP_HEIGHT;
                } while (Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2)) < 500 || 
                       checkWallCollision(x, y));
                
                enemies.push({
                    x: x,
                    y: y,
                    width: 30,
                    height: 50,
                    health: 100,
                    speed: ENEMY_SPEED
                });
                
                lastEnemySpawn = 0;
            }
        }
        
        function updateEnemies(deltaTime) {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // Simple AI: move toward player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 200) { // Only move if far away
                    const angle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
                    enemy.y += Math.sin(angle) * enemy.speed * deltaTime;
                }
                
                // Check if enemy hits player
                if (distance < player.width / 2 + enemy.width / 2) {
                    player.health -= 5 * deltaTime;
                    updateHealthBar();
                    
                    if (player.health <= 0) {
                        player.health = 0;
                        addKillFeed("You died!");
                    }
                }
            }
        }
        
        function updateHealthBar() {
            const healthFill = document.getElementById('healthFill');
            healthFill.style.width = `${player.health}%`;
            
            if (player.health < 30) {
                healthFill.style.backgroundColor = '#e74c3c';
            } else if (player.health < 60) {
                healthFill.style.backgroundColor = '#f39c12';
            } else {
                healthFill.style.backgroundColor = '#2ecc71';
            }
        }
        
        function updateAmmoInfo() {
            const weapon = player.weapons[player.currentWeapon];
            document.getElementById('ammoInfo').textContent = 
                `${weapon.ammo} / ${weapon.maxAmmo}`;
        }
        
        function updateWeaponInfo() {
            document.getElementById('weaponInfo').textContent = 
                player.weapons[player.currentWeapon].name;
            updateAmmoInfo();
        }
        
        function addKillFeed(message) {
            const killFeed = document.getElementById('killFeed');
            const entry = document.createElement('div');
            entry.className = 'killEntry';
            entry.textContent = message;
            killFeed.insertBefore(entry, killFeed.firstChild);
            
            // Remove old entries
            if (killFeed.children.length > 5) {
                killFeed.removeChild(killFeed.lastChild);
            }
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw map (with camera offset)
            const startCol = Math.max(0, Math.floor(camera.x / CELL_SIZE));
            const startRow = Math.max(0, Math.floor(camera.y / CELL_SIZE));
            const endCol = Math.min(map[0].length, Math.ceil((camera.x + canvas.width) / CELL_SIZE));
            const endRow = Math.min(map.length, Math.ceil((camera.y + canvas.height) / CELL_SIZE));
            
            for (let row = startRow; row < endRow; row++) {
                for (let col = startCol; col < endCol; col++) {
                    const x = col * CELL_SIZE - camera.x;
                    const y = row * CELL_SIZE - camera.y;
                    
                    if (map[row][col] === 1) {
                        // Draw wall
                        ctx.fillStyle = '#8B4513'; // Brown
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#654321';
                        ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
                    } else {
                        // Draw floor
                        ctx.fillStyle = '#b5a642'; // Dust color
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#9c8e38';
                        ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // Draw enemies
            ctx.fillStyle = '#e74c3c'; // Red
            for (const enemy of enemies) {
                const x = enemy.x - camera.x - enemy.width / 2;
                const y = enemy.y - camera.y - enemy.height / 2;
                
                // Body
                ctx.fillRect(x, y, enemy.width, enemy.height);
                
                // Health bar
                const healthWidth = enemy.width * (enemy.health / 100);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(x, y - 10, healthWidth, 5);
                ctx.fillStyle = '#e74c3c';
            }
            
            // Draw bullets
            ctx.fillStyle = '#f1c40f'; // Yellow
            for (const bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x - camera.x, bullet.y - camera.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw player
            const playerX = player.x - camera.x - player.width / 2;
            const playerY = player.y - camera.y - player.height / 2;
            ctx.fillStyle = '#3498db'; // Blue
            ctx.fillRect(playerX, playerY, player.width, player.height);
            
            // Draw weapon direction
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.x - camera.x, player.y - camera.y);
            ctx.lineTo(
                player.x - camera.x + Math.cos(player.angle) * 40,
                player.y - camera.y + Math.sin(player.angle) * 40
            );
            ctx.stroke();
        }
        
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            updatePlayer(deltaTime);
            updateBullets(deltaTime);
            spawnEnemies(deltaTime);
            updateEnemies(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        window.onload = init;
    </script>
</body>
</html>