<!DOCTYPE html>
<html>
<head>
    <title>Продвинутый 3D Shooter</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            color: white;
            background-color: #000;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            transition: all 0.1s;
        }
        #crosshair-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            border: 2px solid rgba(255, 0, 0, 0.7);
            transition: all 0.05s;
        }
        #crosshair-outer {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            transition: all 0.2s;
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #menu h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #ff5555;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        .menu-btn {
            padding: 12px 24px;
            font-size: 1.2em;
            background: linear-gradient(to bottom, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            min-width: 200px;
            transition: all 0.3s;
        }
        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
        }
        #health-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #333;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #ff9900, #00ff00);
            transition: width 0.3s;
        }
        #ammo {
            position: absolute;
            bottom: 60px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            border: 2px solid #333;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #333;
        }
        #multiplayer-ui {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            border: 2px solid #333;
        }
        #chat-container {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            display: none;
            border: 2px solid #333;
        }
        #chat-messages {
            height: 150px;
            overflow-y: auto;
            padding: 10px;
        }
        #chat-input {
            width: calc(100% - 20px);
            padding: 5px;
            margin: 5px;
            border: none;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.9);
        }
        #ability-cooldown {
            position: absolute;
            bottom: 160px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            border: 2px solid #333;
        }
        #ability-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #0066ff, #00ccff);
            transition: width 0.1s;
        }
        #ability-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 0.8em;
            line-height: 20px;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #hit-marker::before, #hit-marker::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 50, 50, 0.8);
        }
        #hit-marker::before {
            top: 0;
            left: 50%;
            width: 2px;
            height: 20px;
            transform: translateX(-50%);
        }
        #hit-marker::after {
            left: 0;
            top: 50%;
            width: 20px;
            height: 2px;
            transform: translateY(-50%);
        }
        #weapon-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #333;
        }
        #kill-feed {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            padding: 5px;
            border: 2px solid #333;
        }
        .kill-feed-item {
            margin: 5px;
            font-size: 0.9em;
            color: #fff;
        }
        #radar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 2px solid #333;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Управление: WASD - движение, SPACE - прыжок, SHIFT - бег, ЛКМ - стрельба, R - перезарядка, Q - умение, T - чат</div>
    </div>
    <div id="crosshair">
        <div id="crosshair-outer"></div>
        <div id="crosshair-inner"></div>
    </div>
    <div id="hit-marker"></div>
    <div id="health-bar"><div id="health-fill"></div></div>
    <div id="ammo">30/120</div>
    <div id="score">0 очков</div>
    <div id="weapon-info">Пистолет</div>
    <div id="kill-feed"></div>
    <div id="radar"></div>
    <div id="ability-cooldown">
        <div id="ability-fill"></div>
        <div id="ability-text">Умение готово</div>
    </div>
    <div id="multiplayer-ui">
        <h3>Игроки онлайн:</h3>
        <div id="players-list"></div>
    </div>
    <div id="chat-container">
        <div id="chat-messages"></div>
        <input type="text" id="chat-input" placeholder="Напишите сообщение...">
    </div>

    <div id="menu">
        <h1>ADVANCED SHOOTER</h1>
        <button id="startBtn" class="menu-btn">Одиночная игра</button>
        <button id="multiplayerBtn" class="menu-btn">Мультиплеер</button>
        <button id="settingsBtn" class="menu-btn">Настройки</button>
        <div id="settings" style="display: none; margin-top: 20px; text-align: center;">
            <div style="margin: 10px;">
                <label for="volume">Громкость: </label>
                <input type="range" id="volume" min="0" max="1" step="0.1" value="0.5">
            </div>
            <div style="margin: 10px;">
                <label for="sensitivity">Чувствительность мыши: </label>
                <input type="range" id="sensitivity" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div style="margin: 10px;">
                <label for="graphics">Качество графики: </label>
                <select id="graphics">
                    <option value="low">Низкое</option>
                    <option value="medium" selected>Среднее</option>
                    <option value="high">Высокое</option>
                </select>
            </div>
            <button id="backBtn" class="menu-btn" style="background: linear-gradient(to bottom, #555555, #333333);">Назад</button>
        </div>
    </div>

    <!-- Three.js и дополнительные библиотеки -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Howler.js для звуков -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <!-- Cannon.js для физики -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- GLTFLoader для 3D моделей -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- FBXLoader для анимированных моделей -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <!-- Firebase для мультиплеера -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>

    <script>
        // Конфигурация Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDummyKeyDontUseThisInProduction",
            authDomain: "your-project-id.firebaseapp.com",
            databaseURL: "https://your-project-id.firebaseio.com",
            projectId: "your-project-id",
            storageBucket: "your-project-id.appspot.com",
            messagingSenderId: "123456789012",
            appId: "1:123456789012:web:abcdef1234567890abcdef"
        };

        // Инициализация Firebase (закомментировано для примера)
        // firebase.initializeApp(firebaseConfig);
        // const database = firebase.database();
        // const auth = firebase.auth();

        // Основные переменные игры
        let scene, camera, renderer, controls, world;
        let composer, bloomPass, outlinePass, fxaaPass;
        let enemies = [];
        let bonuses = [];
        let destructibles = [];
        let covers = [];
        let weapons = [];
        let currentWeaponIndex = 0;
        let score = 0;
        let health = 100;
        let maxHealth = 100;
        let ammo = 30;
        let maxAmmo = 120;
        let isGameRunning = false;
        let isMultiplayer = false;
        let playerBody;
        let playerModel;
        let clock = new THREE.Clock();
        let lastEnemySpawn = 0;
        let enemySpawnInterval = 3;
        let playerVelocity = new THREE.Vector3();
        let playerDirection = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isRunning = false;
        let isReloading = false;
        let lastShot = 0;
        let fireRate = 0.1;
        let playerHeight = 1.8;
        let playerRadius = 0.5;
        let gravity = -9.8 * 2;
        let jumpForce = 8;
        let walkSpeed = 4;
        let runSpeed = 8;
        let currentSpeed = walkSpeed;
        let mouseSensitivity = 1;
        let volume = 0.5;
        let graphicsQuality = 'medium';
        let isChatOpen = false;
        let abilityCooldown = false;
        let abilityCooldownTime = 10;
        let abilityCooldownTimer = 0;
        let playerAnimations = {};
        let mixer;
        let currentAnimation;
        let bullets = [];
        let muzzleFlash = null;
        let hitMarkerTimeout = null;
        let killFeedTimeout = null;
        let radarCanvas, radarCtx;
        let skybox;

        // Типы оружия
        const weaponTypes = [
            { name: "Пистолет", damage: 25, fireRate: 0.2, ammo: 15, maxAmmo: 60, reloadTime: 1.5, model: "pistol.glb", sound: "pistol.mp3", bulletSpeed: 100, bulletSize: 0.05, bulletColor: 0xffff00 },
            { name: "Автомат", damage: 15, fireRate: 0.1, ammo: 30, maxAmmo: 120, reloadTime: 2.5, model: "rifle.glb", sound: "rifle.mp3", bulletSpeed: 120, bulletSize: 0.03, bulletColor: 0x00ffff },
            { name: "Дробовик", damage: 50, fireRate: 0.8, ammo: 8, maxAmmo: 32, reloadTime: 3.5, model: "shotgun.glb", sound: "shotgun.mp3", bulletSpeed: 80, bulletSize: 0.08, bulletColor: 0xff8800 },
            { name: "Снайперка", damage: 80, fireRate: 1.2, ammo: 5, maxAmmo: 20, reloadTime: 3.0, model: "sniper.glb", sound: "sniper.mp3", bulletSpeed: 150, bulletSize: 0.04, bulletColor: 0xff00ff }
        ];

        // Типы врагов
        const enemyTypes = [
            { 
                name: "Солдат", 
                color: 0xff0000, 
                speed: 1.5, 
                health: 50, 
                damage: 10, 
                score: 10,
                model: "soldier.fbx",
                animations: {
                    idle: "soldier_idle.fbx",
                    walk: "soldier_walk.fbx",
                    attack: "soldier_attack.fbx",
                    death: "soldier_death.fbx"
                }
            },
            { 
                name: "Разведчик", 
                color: 0x00ff00, 
                speed: 3.0, 
                health: 30, 
                damage: 5, 
                score: 20,
                model: "scout.fbx",
                animations: {
                    idle: "scout_idle.fbx",
                    walk: "scout_run.fbx",
                    attack: "scout_attack.fbx",
                    death: "scout_death.fbx"
                }
            },
            { 
                name: "Танк", 
                color: 0x0000ff, 
                speed: 0.8, 
                health: 100, 
                damage: 20, 
                score: 30,
                model: "heavy.fbx",
                animations: {
                    idle: "heavy_idle.fbx",
                    walk: "heavy_walk.fbx",
                    attack: "heavy_attack.fbx",
                    death: "heavy_death.fbx"
                }
            },
            { 
                name: "Элита", 
                color: 0xffff00, 
                speed: 2.0, 
                health: 40, 
                damage: 15, 
                score: 25,
                model: "elite.fbx",
                animations: {
                    idle: "elite_idle.fbx",
                    walk: "elite_run.fbx",
                    attack: "elite_attack.fbx",
                    death: "elite_death.fbx"
                }
            }
        ];

        // Типы бонусов
        const bonusTypes = [
            { type: 'health', name: "Аптечка", color: 0x00ff00, amount: 25, model: "medkit.glb" },
            { type: 'ammo', name: "Патроны", color: 0xffff00, amount: 30, model: "ammo.glb" },
            { type: 'speed', name: "Энергетик", color: 0x0000ff, amount: 2, model: "energy.glb" },
            { type: 'damage', name: "Усиление", color: 0xff0000, amount: 1.5, model: "damage.glb" },
            { type: 'weapon', name: "Оружие", color: 0xaa00ff, amount: 0, model: "weapon_crate.glb" }
        ];

        // Звуки
        const sounds = {
            shoot: [
                new Howl({ src: ['https://assets.codepen.io/21542/howler-gun-shot.mp3'], volume: 0.7 }),
                new Howl({ src: ['https://assets.codepen.io/21542/howler-gun-shot-2.mp3'], volume: 0.7 }),
                new Howl({ src: ['https://assets.codepen.io/21542/howler-gun-shot-3.mp3'], volume: 0.7 })
            ],
            hit: new Howl({ src: ['https://assets.codepen.io/21542/howler-hit.mp3'], volume: 0.5 }),
            death: new Howl({ src: ['https://assets.codepen.io/21542/howler-death.mp3'], volume: 0.5 }),
            reload: new Howl({ src: ['https://assets.codepen.io/21542/howler-reload.mp3'], volume: 0.5 }),
            pickup: new Howl({ src: ['https://assets.codepen.io/21542/howler-pickup.mp3'], volume: 0.5 }),
            jump: new Howl({ src: ['https://assets.codepen.io/21542/howler-jump.mp3'], volume: 0.3 }),
            hurt: new Howl({ src: ['https://assets.codepen.io/21542/howler-hurt.mp3'], volume: 0.5 }),
            ability: new Howl({ src: ['https://assets.codepen.io/21542/howler-ability.mp3'], volume: 0.7 }),
            explosion: new Howl({ src: ['https://assets.codepen.io/21542/howler-explosion.mp3'], volume: 0.8 }),
            weapon_switch: new Howl({ src: ['https://assets.codepen.io/21542/howler-weapon-switch.mp3'], volume: 0.3 })
        };

        // Инициализация игры
        function init() {
            // Сцена
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            // Камера
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerHeight;

            // Рендерер
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // Post-processing
            initPostProcessing();

            // Физический мир
            world = new CANNON.World();
            world.gravity.set(0, gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Управление
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // Освещение
            setupLighting();

            // Создание мира
            createWorld();

            // Создание скайбокса
            createSkybox();

            // Инициализация радара
            initRadar();

            // Загрузка модели игрока
            loadPlayerModel();

            // Загрузка оружия
            loadWeapons();

            // Создание эффекта дульного вспышки
            createMuzzleFlash();

            // Слушатели событий
            setupEventListeners();

            // Начальное состояние UI
            updateUI();
        }

        // Создание скайбокса
        function createSkybox() {
            const loader = new THREE.TextureLoader();
            const texture = loader.load('https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg');
            texture.mapping = THREE.CubeReflectionMapping;
            
            scene.background = new THREE.Color(0x000000);
            
            // Добавляем туман для создания атмосферы
            scene.fog = new THREE.FogExp2(0x000000, 0.001);
        }

        // Инициализация радара
        function initRadar() {
            radarCanvas = document.createElement('canvas');
            radarCanvas.width = 120;
            radarCanvas.height = 120;
            radarCtx = radarCanvas.getContext('2d');
            
            document.getElementById('radar').appendChild(radarCanvas);
        }

        // Обновление радара
        function updateRadar() {
            radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);
            
            // Отрисовка круга радара
            radarCtx.beginPath();
            radarCtx.arc(60, 60, 50, 0, Math.PI * 2);
            radarCtx.strokeStyle = '#00ff00';
            radarCtx.lineWidth = 2;
            radarCtx.stroke();
            
            // Отрисовка центра (игрока)
            radarCtx.beginPath();
            radarCtx.arc(60, 60, 3, 0, Math.PI * 2);
            radarCtx.fillStyle = '#00ff00';
            radarCtx.fill();
            
            // Отрисовка врагов на радаре
            enemies.forEach(enemy => {
                const dx = enemy.body.position.x - playerBody.position.x;
                const dz = enemy.body.position.z - playerBody.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 50) { // Показываем только близких врагов
                    const angle = Math.atan2(dz, dx) - Math.PI/2 - controls.getObject().rotation.y;
                    const x = 60 + Math.cos(angle) * (distance / 50 * 50);
                    const y = 60 + Math.sin(angle) * (distance / 50 * 50);
                    
                    radarCtx.beginPath();
                    radarCtx.arc(x, y, 3, 0, Math.PI * 2);
                    radarCtx.fillStyle = '#ff0000';
                    radarCtx.fill();
                }
            });
            
            // Отрисовка бонусов на радаре
            bonuses.forEach(bonus => {
                const dx = bonus.body.position.x - playerBody.position.x;
                const dz = bonus.body.position.z - playerBody.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 50) {
                    const angle = Math.atan2(dz, dx) - Math.PI/2 - controls.getObject().rotation.y;
                    const x = 60 + Math.cos(angle) * (distance / 50 * 50);
                    const y = 60 + Math.sin(angle) * (distance / 50 * 50);
                    
                    radarCtx.beginPath();
                    radarCtx.arc(x, y, 3, 0, Math.PI * 2);
                    radarCtx.fillStyle = '#ffff00';
                    radarCtx.fill();
                }
            });
        }

        // Инициализация post-processing
        function initPostProcessing() {
            const renderScene = new THREE.RenderPass(scene, camera);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.4, // radius
                0.85 // threshold
            );
            
            outlinePass = new THREE.OutlinePass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                scene,
                camera
            );
            outlinePass.edgeStrength = 3.0;
            outlinePass.edgeGlow = 0.5;
            outlinePass.edgeThickness = 1.0;
            outlinePass.pulsePeriod = 0;
            
            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outlinePass);
            composer.addPass(fxaaPass);
        }

        // Создание эффекта дульного вспышки
        function createMuzzleFlash() {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff9900,
                transparent: true,
                opacity: 0
            });
            muzzleFlash = new THREE.Mesh(geometry, material);
            muzzleFlash.position.set(0.5, -0.3, -1.2);
            camera.add(muzzleFlash);
        }

        // Анимация дульного вспышки
        function animateMuzzleFlash() {
            if (!muzzleFlash) return;
            
            muzzleFlash.material.opacity = 1;
            muzzleFlash.scale.set(1, 1, 1);
            
            let scale = 1;
            const animate = () => {
                scale += 0.2;
                muzzleFlash.scale.set(scale, scale, scale);
                muzzleFlash.material.opacity = 1 - (scale - 1) / 3;
                
                if (scale >= 4) {
                    muzzleFlash.material.opacity = 0;
                    return;
                }
                
                requestAnimationFrame(animate);
            };
            
            animate();
        }

        // Настройка освещения
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
            scene.add(ambientLight);

            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Hemisphere light for more natural outdoor lighting
            const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
            scene.add(hemisphereLight);

            // Point lights for additional illumination
            const pointLight1 = new THREE.PointLight(0xffaa00, 0.5, 20);
            pointLight1.position.set(5, 5, 5);
            pointLight1.castShadow = true;
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00aaff, 0.5, 20);
            pointLight2.position.set(-5, 5, -5);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
        }

        // Создание игрового мира
        function createWorld() {
            // Пол (земля)
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5f0b,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Физическое тело для земли
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // Физическое тело игрока
            const playerShape = new CANNON.Sphere(playerRadius);
            playerBody = new CANNON.Body({ mass: 5 });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, playerHeight, 0);
            playerBody.linearDamping = 0.5;
            world.addBody(playerBody);

            // Создание укрытий
            createCovers();

            // Создание разрушаемых объектов
            createDestructibles();
        }

        // Создание укрытий
        function createCovers() {
            const coverPositions = [
                { x: 10, z: 5, width: 3, depth: 1, height: 1.5 },
                { x: -8, z: 15, width: 2, depth: 4, height: 1.2 },
                { x: 5, z: -12, width: 5, depth: 1, height: 1.8 },
                { x: -15, z: -5, width: 1, depth: 3, height: 1.3 }
            ];

            coverPositions.forEach(pos => {
                const geometry = new THREE.BoxGeometry(pos.width, pos.height, pos.depth);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9,
                    metalness: 0.1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, pos.height/2, pos.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Физическое тело укрытия
                const shape = new CANNON.Box(new CANNON.Vec3(pos.width/2, pos.height/2, pos.depth/2));
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(shape);
                body.position.copy(mesh.position);
                world.addBody(body);

                covers.push({ mesh, body });
            });
        }

        // Создание разрушаемых объектов
        function createDestructibles() {
            const destructiblePositions = [
                { x: 7, z: 8, size: 1.2 },
                { x: -5, z: 10, size: 0.8 },
                { x: 12, z: -7, size: 1.5 },
                { x: -10, z: -8, size: 1.0 }
            ];

            destructiblePositions.forEach(pos => {
                const geometry = new THREE.BoxGeometry(pos.size, pos.size, pos.size);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xC0C0C0,
                    roughness: 0.5,
                    metalness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, pos.size/2, pos.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Физическое тело объекта
                const shape = new CANNON.Box(new CANNON.Vec3(pos.size/2, pos.size/2, pos.size/2));
                const body = new CANNON.Body({ mass: 5 });
                body.addShape(shape);
                body.position.copy(mesh.position);
                world.addBody(body);

                destructibles.push({ 
                    mesh, 
                    body,
                    health: 100,
                    size: pos.size
                });
            });
        }

        // Загрузка модели игрока
        function loadPlayerModel() {
            const loader = new THREE.FBXLoader();
            loader.load(
                'https://threejs.org/examples/models/fbx/Samba%20Dancing.fbx',
                function (object) {
                    playerModel = object;
                    playerModel.scale.set(0.01, 0.01, 0.01);
                    playerModel.position.y = -playerHeight;
                    playerModel.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Создаем анимационный миксер
                    mixer = new THREE.AnimationMixer(playerModel);
                    
                    // Добавляем модель игрока к камере (так она будет следовать за игроком)
                    camera.add(playerModel);
                    
                    // Загружаем анимации
                    loadPlayerAnimations();
                },
                undefined,
                function (error) {
                    console.error('Ошибка загрузки модели игрока:', error);
                    // Простая модель как fallback
                    const geometry = new THREE.CapsuleGeometry(0.3, 1, 4, 8);
                    const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                    playerModel = new THREE.Mesh(geometry, material);
                    playerModel.position.y = -playerHeight;
                    camera.add(playerModel);
                }
            );
        }

        // Загрузка анимаций игрока
        function loadPlayerAnimations() {
            // В реальном проекте здесь нужно загрузить анимации из файлов
            // Для примера создадим пустые анимации
            
            playerAnimations = {
                idle: { clip: null, action: null },
                walk: { clip: null, action: null },
                run: { clip: null, action: null },
                jump: { clip: null, action: null },
                shoot: { clip: null, action: null },
                reload: { clip: null, action: null }
            };
            
            // Для демонстрации просто установим idle анимацию
            setAnimation('idle');
        }

        // Установка текущей анимации
        function setAnimation(name) {
            if (!mixer || currentAnimation === name) return;
            
            if (currentAnimation) {
                const prevAction = playerAnimations[currentAnimation].action;
                if (prevAction) prevAction.stop();
            }
            
            const animData = playerAnimations[name];
            if (animData && animData.clip) {
                const action = mixer.clipAction(animData.clip);
                action.play();
                animData.action = action;
                currentAnimation = name;
            }
        }

        // Загрузка оружия
        function loadWeapons() {
            const loader = new THREE.GLTFLoader();
            
            weaponTypes.forEach((weapon, index) => {
                loader.load(
                    `models/weapons/${weapon.model}`,
                    function (gltf) {
                        const model = gltf.scene;
                        model.scale.set(0.5, 0.5, 0.5);
                        model.position.set(0.5, -0.3, -0.8);
                        model.rotation.set(0, Math.PI, 0);
                        model.visible = (index === 0); // Показываем только первое оружие
                        
                        // Добавляем оружие в массив
                        weapons.push({
                            model,
                            type: weapon,
                            ammo: weapon.ammo,
                            maxAmmo: weapon.maxAmmo
                        });
                        
                        // Добавляем модель к камере
                        camera.add(model);
                    },
                    undefined,
                    function (error) {
                        console.error(`Ошибка загрузки оружия ${weapon.name}:`, error);
                        // Простое оружие как fallback
                        const geometry = new THREE.BoxGeometry(0.3, 0.2, 0.8);
                        const material = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const model = new THREE.Mesh(geometry, material);
                        model.position.set(0.5, -0.3, -0.8);
                        model.visible = (index === 0);
                        
                        weapons.push({
                            model,
                            type: weapon,
                            ammo: weapon.ammo,
                            maxAmmo: weapon.maxAmmo
                        });
                        
                        camera.add(model);
                    }
                );
            });
        }

        // Создание пули
        function createBullet(position, direction) {
            const weapon = weapons[currentWeaponIndex].type;
            const geometry = new THREE.SphereGeometry(weapon.bulletSize, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: weapon.bulletColor,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            scene.add(mesh);

            // Физическое тело пули
            const shape = new CANNON.Sphere(weapon.bulletSize);
            const body = new CANNON.Body({ mass: 0.1 });
            body.addShape(shape);
            body.position.copy(position);
            body.velocity.copy(direction.multiplyScalar(weapon.bulletSpeed));
            world.addBody(body);

            // Добавляем пулю в массив
            bullets.push({
                mesh,
                body,
                damage: weapon.damage,
                time: 0,
                maxTime: 2 // Время жизни пули в секундах
            });

            return mesh;
        }

        // Обновление пуль
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.time += delta;
                
                // Обновление позиции меша пули
                bullet.mesh.position.copy(bullet.body.position);
                
                // Проверка столкновений
                checkBulletCollisions(bullet, i);
                
                // Удаление старых пуль
                if (bullet.time >= bullet.maxTime) {
                    scene.remove(bullet.mesh);
                    world.removeBody(bullet.body);
                    bullets.splice(i, 1);
                }
            }
        }

        // Проверка столкновений пуль
        function checkBulletCollisions(bullet, bulletIndex) {
            // Проверка столкновения с врагами
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const distance = bullet.body.position.distanceTo(enemy.body.position);
                
                if (distance < 0.5 + weapons[currentWeaponIndex].type.bulletSize) {
                    enemy.health -= bullet.damage;
                    
                    // Эффект попадания
                    createHitEffect(bullet.body.position);
                    
                    // Добавление в ленту убийств
                    addKillFeed(`Вы попали в ${enemy.type.name} (${enemy.health}/${enemy.type.health} HP)`);
                    
                    // Удаление пули
                    scene.remove(bullet.mesh);
                    world.removeBody(bullet.body);
                    bullets.splice(bulletIndex, 1);
                    
                    // Проверка на смерть врага
                    if (enemy.health <= 0) {
                        score += enemy.score;
                        scene.remove(enemy.mesh);
                        world.removeBody(enemy.body);
                        enemies.splice(i, 1);
                        
                        // Добавление в ленту убийств
                        addKillFeed(`Вы убили ${enemy.type.name} (+${enemy.score} очков)`);
                        
                        // С шансом 30% выпадет бонус
                        if (Math.random() < 0.3) {
                            createBonuses(1);
                        }
                    }
                    
                    return;
                }
            }
            
            // Проверка столкновения с разрушаемыми объектами
            for (let i = destructibles.length - 1; i >= 0; i--) {
                const obj = destructibles[i];
                const distance = bullet.body.position.distanceTo(obj.body.position);
                
                if (distance < obj.size / 2 + weapons[currentWeaponIndex].type.bulletSize) {
                    obj.health -= bullet.damage;
                    
                    // Эффект попадания
                    createHitEffect(bullet.body.position);
                    
                    // Удаление пули
                    scene.remove(bullet.mesh);
                    world.removeBody(bullet.body);
                    bullets.splice(bulletIndex, 1);
                    
                    // Проверка на разрушение объекта
                    if (obj.health <= 0) {
                        // Эффект разрушения
                        createExplosion(obj.mesh.position.x, obj.mesh.position.y, obj.mesh.position.z, obj.size);
                        
                        scene.remove(obj.mesh);
                        world.removeBody(obj.body);
                        destructibles.splice(i, 1);
                        
                        // С шансом 50% выпадет бонус
                        if (Math.random() < 0.5) {
                            createBonuses(1);
                        }
                    }
                    
                    return;
                }
            }
        }

        // Добавление сообщения в ленту убийств
        function addKillFeed(message) {
            const killFeed = document.getElementById('kill-feed');
            const item = document.createElement('div');
            item.className = 'kill-feed-item';
            item.textContent = message;
            killFeed.appendChild(item);
            
            // Автоматическое удаление через 5 секунд
            setTimeout(() => {
                killFeed.removeChild(item);
            }, 5000);
        }

        // Переключение оружия
        function switchWeapon(index) {
            if (index < 0 || index >= weapons.length || index === currentWeaponIndex) return;
            
            // Скрываем текущее оружие
            weapons[currentWeaponIndex].model.visible = false;
            
            // Показываем новое оружие
            currentWeaponIndex = index;
            weapons[currentWeaponIndex].model.visible = true;
            
            // Обновляем UI
            ammo = weapons[currentWeaponIndex].ammo;
            maxAmmo = weapons[currentWeaponIndex].maxAmmo;
            fireRate = weapons[currentWeaponIndex].type.fireRate;
            document.getElementById('weapon-info').textContent = weapons[currentWeaponIndex].type.name;
            updateUI();
            
            // Проигрываем звук смены оружия
            sounds.weapon_switch.play();
        }

        // Настройка слушателей событий
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onClick);
            document.addEventListener('keypress', onKeyPress);
            document.getElementById('startBtn').addEventListener('click', startSinglePlayer);
            document.getElementById('multiplayerBtn').addEventListener('click', startMultiplayer);
            document.getElementById('settingsBtn').addEventListener('click', showSettings);
            document.getElementById('backBtn').addEventListener('click', hideSettings);
            document.getElementById('volume').addEventListener('input', updateVolume);
            document.getElementById('sensitivity').addEventListener('input', updateSensitivity);
            document.getElementById('graphics').addEventListener('change', updateGraphics);
            document.getElementById('chat-input').addEventListener('keydown', onChatInput);
            window.addEventListener('resize', onWindowResize);
        }

        // Начать одиночную игру
        function startSinglePlayer() {
            isMultiplayer = false;
            startGame();
        }

        // Начать мультиплеер
        function startMultiplayer() {
            isMultiplayer = true;
            document.getElementById('multiplayer-ui').style.display = 'block';
            document.getElementById('chat-container').style.display = 'block';
            document.getElementById('ability-cooldown').style.display = 'block';
            startGame();
            // Здесь должна быть логика подключения к Firebase
        }

        // Показать настройки
        function showSettings() {
            document.getElementById('settings').style.display = 'block';
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('multiplayerBtn').style.display = 'none';
            document.getElementById('settingsBtn').style.display = 'none';
        }

        // Скрыть настройки
        function hideSettings() {
            document.getElementById('settings').style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('multiplayerBtn').style.display = 'block';
            document.getElementById('settingsBtn').style.display = 'block';
        }

        // Обновить громкость
        function updateVolume() {
            volume = parseFloat(document.getElementById('volume').value);
            Howler.volume(volume);
        }

        // Обновить чувствительность
        function updateSensitivity() {
            mouseSensitivity = parseFloat(document.getElementById('sensitivity').value);
        }

        // Обновить качество графики
        function updateGraphics() {
            graphicsQuality = document.getElementById('graphics').value;
            
            switch(graphicsQuality) {
                case 'low':
                    renderer.shadowMap.enabled = false;
                    bloomPass.strength = 0.5;
                    renderer.toneMapping = THREE.NoToneMapping;
                    break;
                case 'medium':
                    renderer.shadowMap.enabled = true;
                    bloomPass.strength = 1.0;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.0;
                    break;
                case 'high':
                    renderer.shadowMap.enabled = true;
                    bloomPass.strength = 1.5;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.2;
                    break;
            }
        }

        // Начать игру
        function startGame() {
            // Очистка предыдущего состояния
            enemies.forEach(enemy => {
                scene.remove(enemy.mesh);
                world.removeBody(enemy.body);
            });
            bonuses.forEach(bonus => {
                scene.remove(bonus.mesh);
                world.removeBody(bonus.body);
            });
            destructibles.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            bullets.forEach(bullet => {
                scene.remove(bullet.mesh);
                world.removeBody(bullet.body);
            });
            
            enemies = [];
            bonuses = [];
            destructibles = [];
            bullets = [];
            score = 0;
            health = maxHealth;
            ammo = weapons[currentWeaponIndex].ammo;
            maxAmmo = weapons[currentWeaponIndex].maxAmmo;
            isGameRunning = true;
            lastEnemySpawn = 0;

            // Сброс позиции игрока
            playerBody.position.set(0, playerHeight, 0);
            playerBody.velocity.set(0, 0, 0);
            playerBody.angularVelocity.set(0, 0, 0);

            // Показать UI
            document.getElementById('menu').style.display = 'none';
            controls.lock();

            // Создать начальных врагов и бонусы
            createEnemies(5);
            createBonuses(3);
            createDestructibles();

            // Обновить UI
            updateUI();
        }

        // Создать врагов
        function createEnemies(count) {
            const loader = new THREE.FBXLoader();
            
            for (let i = 0; i < count; i++) {
                const type = Math.floor(Math.random() * enemyTypes.length);
                const enemyType = enemyTypes[type];
                
                loader.load(
                    `models/enemies/${enemyType.model}`,
                    function (object) {
                        object.scale.set(0.01, 0.01, 0.01);
                        object.traverse(function (child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        // Позиция врага
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 15 + Math.random() * 30;
                        object.position.x = Math.cos(angle) * distance;
                        object.position.z = Math.sin(angle) * distance;
                        object.position.y = 0;
                        
                        // Физическое тело врага
                        const size = 0.5 + Math.random() * 0.3;
                        const shape = new CANNON.Sphere(size * 0.5);
                        const body = new CANNON.Body({ mass: 1 });
                        body.addShape(shape);
                        body.position.copy(object.position);
                        
                        // Добавление в мир
                        scene.add(object);
                        world.addBody(body);
                        
                        // Анимации врага
                        const enemyMixer = new THREE.AnimationMixer(object);
                        const animations = {};
                        
                        // Загрузка анимаций (в реальном проекте нужно загрузить из файлов)
                        // Для примера просто создаем пустые анимации
                        
                        // Сохранение врага
                        enemies.push({
                            mesh: object,
                            body,
                            type: enemyType,
                            health: enemyType.health,
                            speed: enemyType.speed,
                            damage: enemyType.damage,
                            score: enemyType.score,
                            mixer: enemyMixer,
                            animations,
                            currentAnim: 'idle'
                        });
                    },
                    undefined,
                    function (error) {
                        console.error('Ошибка загрузки модели врага:', error);
                        // Простая модель как fallback
                        const size = 0.5 + Math.random() * 0.3;
                        const geometry = new THREE.BoxGeometry(size, size, size);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: enemyType.color,
                            roughness: 0.7,
                            metalness: 0.3
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        
                        // Позиция врага
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 15 + Math.random() * 30;
                        mesh.position.x = Math.cos(angle) * distance;
                        mesh.position.z = Math.sin(angle) * distance;
                        mesh.position.y = size / 2;
                        
                        // Физическое тело врага
                        const shape = new CANNON.Sphere(size * 0.5);
                        const body = new CANNON.Body({ mass: 1 });
                        body.addShape(shape);
                        body.position.copy(mesh.position);
                        
                        // Добавление в мир
                        scene.add(mesh);
                        world.addBody(body);
                        
                        // Сохранение врага
                        enemies.push({
                            mesh,
                            body,
                            type: enemyType,
                            health: enemyType.health,
                            speed: enemyType.speed,
                            damage: enemyType.damage,
                            score: enemyType.score,
                            currentAnim: null
                        });
                    }
                );
            }
        }

        // Создать бонусы
        function createBonuses(count) {
            const loader = new THREE.GLTFLoader();
            
            for (let i = 0; i < count; i++) {
                const type = Math.floor(Math.random() * bonusTypes.length);
                const bonusType = bonusTypes[type];
                const size = 0.5;
                
                loader.load(
                    `models/bonuses/${bonusType.model}`,
                    function (gltf) {
                        const mesh = gltf.scene;
                        mesh.scale.set(size, size, size);
                        mesh.castShadow = true;
                        
                        // Позиция бонуса
                        mesh.position.x = (Math.random() - 0.5) * 40;
                        mesh.position.z = (Math.random() - 0.5) * 40;
                        mesh.position.y = size / 2;
                        
                        // Физическое тело бонуса
                        const shape = new CANNON.Sphere(size * 0.5);
                        const body = new CANNON.Body({ mass: 0 });
                        body.addShape(shape);
                        body.position.copy(mesh.position);
                        
                        // Добавление в мир
                        scene.add(mesh);
                        world.addBody(body);
                        
                        // Анимация вращения
                        mesh.userData.rotationSpeed = Math.random() * 0.02 + 0.01;
                        
                        // Сохранение бонуса
                        bonuses.push({
                            mesh,
                            body,
                            type: bonusType
                        });
                    },
                    undefined,
                    function (error) {
                        console.error('Ошибка загрузки модели бонуса:', error);
                        // Простая модель как fallback
                        const geometry = new THREE.SphereGeometry(size * 0.5, 16, 16);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: bonusType.color,
                            roughness: 0.2,
                            metalness: 0.8,
                            emissive: bonusType.color,
                            emissiveIntensity: 0.5
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        
                        // Позиция бонуса
                        mesh.position.x = (Math.random() - 0.5) * 40;
                        mesh.position.z = (Math.random() - 0.5) * 40;
                        mesh.position.y = size / 2;
                        
                        // Физическое тело бонуса
                        const shape = new CANNON.Sphere(size * 0.5);
                        const body = new CANNON.Body({ mass: 0 });
                        body.addShape(shape);
                        body.position.copy(mesh.position);
                        
                        // Добавление в мир
                        scene.add(mesh);
                        world.addBody(body);
                        
                        // Сохранение бонуса
                        bonuses.push({
                            mesh,
                            body,
                            type: bonusType
                        });
                    }
                );
            }
        }

        // Обработка нажатия клавиш
        function onKeyDown(event) {
            if (isChatOpen) return;
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { playerBody.velocity.y = jumpForce; canJump = false; sounds.jump.play(); } break;
                case 'ShiftLeft': isRunning = true; currentSpeed = runSpeed; break;
                case 'KeyR': reload(); break;
                case 'KeyQ': useAbility(); break;
                case 'Digit1': switchWeapon(0); break;
                case 'Digit2': switchWeapon(1); break;
                case 'Digit3': switchWeapon(2); break;
                case 'Digit4': switchWeapon(3); break;
            }
        }

        // Обработка отпускания клавиш
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; currentSpeed = walkSpeed; break;
            }
        }

        // Обработка нажатия клавиш (для чата)
        function onKeyPress(event) {
            if (event.key === 't' || event.key === 'T') {
                toggleChat();
            }
        }

        // Переключение чата
        function toggleChat() {
            isChatOpen = !isChatOpen;
            if (isChatOpen) {
                document.getElementById('chat-input').focus();
                controls.unlock();
            } else {
                document.getElementById('chat-input').blur();
                controls.lock();
            }
        }

        // Обработка ввода в чат
        function onChatInput(event) {
            if (event.key === 'Enter') {
                const message = document.getElementById('chat-input').value;
                if (message.trim() !== '') {
                    // Отправить сообщение (в реальном проекте через Firebase)
                    addChatMessage('Вы', message);
                    document.getElementById('chat-input').value = '';
                }
                toggleChat();
            }
        }

        // Добавить сообщение в чат
        function addChatMessage(sender, message) {
            const chatMessages = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Использование способности
        function useAbility() {
            if (abilityCooldown) return;
            
            // Активация способности (например, взрыв вокруг игрока)
            sounds.ability.play();
            
            // Визуальный эффект
            createExplosion(playerBody.position.x, playerBody.position.y, playerBody.position.z, 5);
            
            // Урон врагам в радиусе
            enemies.forEach(enemy => {
                const distance = playerBody.position.distanceTo(enemy.body.position);
                if (distance < 5) {
                    enemy.health -= 50;
                    if (enemy.health <= 0) {
                        score += enemy.score;
                        scene.remove(enemy.mesh);
                        world.removeBody(enemy.body);
                        enemies = enemies.filter(e => e !== enemy);
                    }
                }
            });
            
            // Начало перезарядки
            abilityCooldown = true;
            abilityCooldownTimer = abilityCooldownTime;
            document.getElementById('ability-text').textContent = 'Перезарядка...';
            
            // Обновление UI
            updateAbilityCooldown();
        }

        // Обновление перезарядки способности
        function updateAbilityCooldown() {
            if (!abilityCooldown) return;
            
            abilityCooldownTimer -= 0.1;
            const percent = (abilityCooldownTimer / abilityCooldownTime) * 100;
            document.getElementById('ability-fill').style.width = `${100 - percent}%`;
            
            if (abilityCooldownTimer <= 0) {
                abilityCooldown = false;
                document.getElementById('ability-text').textContent = 'Умение готово';
                document.getElementById('ability-fill').style.width = '0%';
            } else {
                setTimeout(updateAbilityCooldown, 100);
            }
        }

        // Создание эффекта взрыва
        function createExplosion(x, y, z, size) {
            // Частицы взрыва
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = x + (Math.random() * 2 - 1) * size;
                positions[i * 3 + 1] = y + (Math.random() * 2 - 1) * size;
                positions[i * 3 + 2] = z + (Math.random() * 2 - 1) * size;
                
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = Math.random() * 0.5 + 0.5;
                colors[i * 3 + 2] = 0.0;
                
                sizes[i] = Math.random() * 0.5 + 0.1;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // Анимация частиц
            let time = 0;
            const animateParticles = () => {
                time += 0.1;
                if (time > 2) {
                    scene.remove(particleSystem);
                    return;
                }
                
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += (Math.random() - 0.5) * 0.2;
                    positions[i + 1] += (Math.random() - 0.5) * 0.2 + 0.1;
                    positions[i + 2] += (Math.random() - 0.5) * 0.2;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                
                particleMaterial.opacity = 1 - (time / 2);
                requestAnimationFrame(animateParticles);
            };
            
            animateParticles();
            
            // Звук взрыва
            sounds.explosion.play();
        }

        // Перезарядка
        function reload() {
            if (isReloading || maxAmmo <= 0 || weapons[currentWeaponIndex].ammo === weapons[currentWeaponIndex].type.ammo) return;
            
            isReloading = true;
            sounds.reload.play();
            
            // Анимация перезарядки
            if (playerAnimations.reload) {
                setAnimation('reload');
            }
            
            setTimeout(() => {
                const weapon = weapons[currentWeaponIndex];
                const needed = weapon.type.ammo - weapon.ammo;
                const available = Math.min(needed, maxAmmo);
                weapon.ammo += available;
                maxAmmo -= available;
                ammo = weapon.ammo;
                isReloading = false;
                updateUI();
                
                // Возврат к idle анимации
                setAnimation('idle');
            }, weapons[currentWeaponIndex].type.reloadTime * 1000);
        }

        // Обработка клика (стрельба)
        function onClick() {
            if (!isGameRunning) {
                controls.lock();
                return;
            }
            
            if (!controls.isLocked || isReloading || isChatOpen) return;
            
            const now = clock.getElapsedTime();
            if (now - lastShot < fireRate || weapons[currentWeaponIndex].ammo <= 0) return;
            
            lastShot = now;
            weapons[currentWeaponIndex].ammo--;
            ammo = weapons[currentWeaponIndex].ammo;
            updateUI();
            
            // Анимация прицела при выстреле
            animateCrosshair();
            
            // Проиграть звук выстрела
            const weaponType = weapons[currentWeaponIndex].type;
            const shootSound = sounds.shoot[Math.floor(Math.random() * sounds.shoot.length)];
            shootSound.play();
            
            // Анимация отдачи оружия
            if (weapons[currentWeaponIndex].model) {
                weapons[currentWeaponIndex].model.position.z += 0.1;
                setTimeout(() => { 
                    if (weapons[currentWeaponIndex].model) {
                        weapons[currentWeaponIndex].model.position.z -= 0.1; 
                    }
                }, 100);
            }
            
            // Анимация дульного вспышки
            animateMuzzleFlash();
            
            // Анимация стрельбы
            if (playerAnimations.shoot) {
                setAnimation('shoot');
                setTimeout(() => {
                    if (moveForward || moveBackward || moveLeft || moveRight) {
                        setAnimation(isRunning ? 'run' : 'walk');
                    } else {
                        setAnimation('idle');
                    }
                }, 200);
            }
            
            // Создание пули
            const weapon = weapons[currentWeaponIndex].type;
            const bulletPosition = new THREE.Vector3();
            camera.getWorldPosition(bulletPosition);
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            createBullet(bulletPosition, direction);
        }

        // Анимация прицела при выстреле
        function animateCrosshair() {
            const inner = document.getElementById('crosshair-inner');
            const outer = document.getElementById('crosshair-outer');
            
            // Уменьшение внутреннего круга
            inner.style.transform = 'translate(-50%, -50%) scale(0.5)';
            outer.style.transform = 'translate(-50%, -50%) scale(1.2)';
            
            // Возврат к исходному состоянию
            setTimeout(() => {
                inner.style.transform = 'translate(-50%, -50%) scale(1)';
                outer.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 100);
        }

        // Показать маркер попадания
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            
            // Сброс предыдущего таймера
            if (hitMarkerTimeout) clearTimeout(hitMarkerTimeout);
            
            // Скрытие маркера через 200 мс
            hitMarkerTimeout = setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 200);
        }

        // Создание эффекта попадания
        function createHitEffect(position) {
            showHitMarker();
            sounds.hit.play();
            
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // Анимация исчезновения
            let scale = 0.1;
            const animateHit = () => {
                scale += 0.1;
                mesh.scale.set(scale, scale, scale);
                material.opacity = 1 - (scale / 2);
                
                if (scale >= 2) {
                    scene.remove(mesh);
                    return;
                }
                
                requestAnimationFrame(animateHit);
            };
            
            animateHit();
        }

        // Обновление UI
        function updateUI() {
            document.getElementById('score').textContent = `${score} очков`;
            document.getElementById('health-fill').style.width = `${(health / maxHealth) * 100}%`;
            document.getElementById('ammo').textContent = `${ammo}/${maxAmmo}`;
        }

        // Проверка столкновений
        function checkCollisions() {
            // Столкновение игрока с врагами
            enemies.forEach(enemy => {
                const distance = playerBody.position.distanceTo(enemy.body.position);
                if (distance < playerRadius + 0.5) {
                    health -= enemy.damage * 0.1; // Урон за касание
                    sounds.hurt.play();
                    
                    // Отталкивание
                    const direction = new CANNON.Vec3();
                    direction.copy(playerBody.position);
                    direction.vsub(enemy.body.position, direction);
                    direction.normalize();
                    direction.scale(5, direction);
                    enemy.body.velocity.copy(direction);
                    
                    if (health <= 0) {
                        gameOver();
                    }
                }
            });
            
            // Столкновение игрока с бонусами
            bonuses.forEach((bonus, index) => {
                const distance = playerBody.position.distanceTo(bonus.body.position);
                if (distance < playerRadius + 0.5) {
                    // Подобрать бонус
                    switch (bonus.type.type) {
                        case 'health':
                            health = Math.min(maxHealth, health + bonus.type.amount);
                            break;
                        case 'ammo':
                            maxAmmo += bonus.type.amount;
                            break;
                        case 'speed':
                            walkSpeed += bonus.type.amount;
                            runSpeed += bonus.type.amount;
                            setTimeout(() => {
                                walkSpeed -= bonus.type.amount;
                                runSpeed -= bonus.type.amount;
                            }, 10000);
                            break;
                        case 'damage':
                            // Можно добавить временное усиление урона
                            break;
                        case 'weapon':
                            // Случайное оружие
                            const randomWeapon = Math.floor(Math.random() * weaponTypes.length);
                            switchWeapon(randomWeapon);
                            break;
                    }
                    
                    sounds.pickup.play();
                    scene.remove(bonus.mesh);
                    world.removeBody(bonus.body);
                    bonuses.splice(index, 1);
                    updateUI();
                }
            });
        }

        // Конец игры
        function gameOver() {
            isGameRunning = false;
            sounds.death.play();
            controls.unlock();
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('startBtn').textContent = 'Заново';
        }

        // Обработка ресайза окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            fxaaPass.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        }

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Обновление анимаций
            if (mixer) mixer.update(delta);
            
            // Обновление анимаций врагов
            enemies.forEach(enemy => {
                if (enemy.mixer) enemy.mixer.update(delta);
            });
            
            // Обновление вращения бонусов
            bonuses.forEach(bonus => {
                if (bonus.mesh.userData.rotationSpeed) {
                    bonus.mesh.rotation.y += bonus.mesh.userData.rotationSpeed;
                }
            });
            
            // Обновление пуль
            updateBullets(delta);
            
            if (controls.isLocked && isGameRunning) {
                // Движение игрока
                const velocity = playerBody.velocity;
                const frontVector = new THREE.Vector3(0, 0, -1).applyQuaternion(controls.getObject().quaternion);
                const sideVector = new THREE.Vector3(-1, 0, 0).applyQuaternion(controls.getObject().quaternion);
                
                playerDirection.set(0, 0, 0);
                
                if (moveForward) playerDirection.add(frontVector);
                if (moveBackward) playerDirection.sub(frontVector);
                if (moveLeft) playerDirection.add(sideVector);
                if (moveRight) playerDirection.sub(sideVector);
                
                playerDirection.normalize();
                playerDirection.multiplyScalar(currentSpeed);
                
                velocity.x = playerDirection.x;
                velocity.z = playerDirection.z;
                
                // Проверка на земле ли игрок
                canJump = playerBody.position.y < playerHeight + 0.1;
                
                // Обновление анимации игрока
                if (playerAnimations) {
                    if (moveForward || moveBackward || moveLeft || moveRight) {
                        setAnimation(isRunning ? 'run' : 'walk');
                    } else if (currentAnimation !== 'idle' && currentAnimation !== 'shoot' && currentAnimation !== 'reload') {
                        setAnimation('idle');
                    }
                }
                
                // Синхронизация позиции камеры с физическим телом
                controls.getObject().position.copy(playerBody.position);
                
                // Движение врагов к игроку
                enemies.forEach(enemy => {
                    const direction = new CANNON.Vec3();
                    direction.copy(playerBody.position);
                    direction.vsub(enemy.body.position, direction);
                    direction.normalize();
                    direction.scale(enemy.speed, direction);
                    direction.y = enemy.body.velocity.y;
                    enemy.body.velocity.copy(direction);
                    
                    // Поворот меша врага в сторону игрока
                    enemy.mesh.lookAt(
                        playerBody.position.x,
                        enemy.mesh.position.y,
                        playerBody.position.z
                    );
                    
                    // Обновление анимации врага
                    if (enemy.animations) {
                        // В реальном проекте нужно переключать анимации в зависимости от состояния
                    }
                });
                
                // Проверка столкновений
                checkCollisions();
                
                // Бесконечная генерация врагов
                const time = clock.getElapsedTime();
                if (time - lastEnemySpawn > enemySpawnInterval) {
                    createEnemies(1);
                    lastEnemySpawn = time;
                    // Увеличиваем сложность
                    enemySpawnInterval = Math.max(0.5, enemySpawnInterval * 0.99);
                }
            }
            
            // Обновление физики
            world.step(1/60, delta, 3);
            
            // Обновление радара
            updateRadar();
            
            // Обновление UI для мультиплеера
            if (isMultiplayer) {
                document.getElementById('players-list').innerHTML = '<div>Игрок 1</div><div>Игрок 2</div>';
            }
            
            // Рендеринг с post-processing
            if (graphicsQuality !== 'low') {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Запуск игры
        init();
        animate();
    </script>
</body>
</html>
