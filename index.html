<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra Realistic 3D Apartment</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            touch-action: none;
            background: #000;
        }
        canvas { 
            display: block; 
            outline: none;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background-color: rgba(0,0,0,0.6);
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 15px;
            line-height: 1.5;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            backdrop-filter: blur(4px);
        }
        #controls {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 12px 24px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 18px;
            transition: opacity 0.5s;
        }
        #progress-bar {
            width: 300px;
            height: 4px;
            background: #333;
            margin-top: 20px;
            border-radius: 2px;
            overflow: hidden;
        }
        #progress {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        #mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            overflow: hidden;
            backdrop-filter: blur(2px);
        }
        #sound-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.6);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading ultra-realistic 3D environment...</div>
        <div id="progress-bar"><div id="progress"></div></div>
    </div>
    
    <div id="ui">
        <div id="info">ULTRA REALISTIC 3D APARTMENT<br>WASD: Move | SPACE: Jump | SHIFT: Run | Mouse: Look</div>
        <div id="controls">WASD: Move | SPACE: Jump | SHIFT: Run | Mouse: Look | ESC: Toggle Menu</div>
        <div id="mini-map"></div>
        <button id="sound-toggle">ðŸ”Š Sound ON</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/SSAOShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/geometries/DecalGeometry.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, composer, controls, clock;
        let livingRoomWidth = 12, livingRoomHeight = 4.5, livingRoomDepth = 8;
        let bedroomWidth = 8, bedroomHeight = 3.5, bedroomDepth = 6;
        let hallwayWidth = 2, hallwayHeight = 3, hallwayLength = 5;
        let objects = [], collidableObjects = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isRunning = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = 0;
        let textureLoader = new THREE.TextureLoader();
        let rgbeLoader = new THREE.RGBELoader();
        let gltfLoader = new THREE.GLTFLoader();
        let environmentMap, decalMaterial;
        let bloomPass, ssaoPass, fxaaPass;
        let pointLight1, pointLight2, directionalLight;
        let loadedAssets = 0, totalAssets = 25;
        let soundEnabled = true;
        let footstepSound, ambientSound;
        let miniMapCamera, miniMapRenderer;

        // Initialize the scene
        init();

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.001);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            // Create renderer with advanced settings
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            // Setup clock
            clock = new THREE.Clock();

            // Setup mini-map
            setupMiniMap();

            // Load assets
            loadAssets();
        }

        function setupMiniMap() {
            miniMapCamera = new THREE.OrthographicCamera(
                -20, 20, 20, -20, 1, 1000
            );
            miniMapCamera.position.set(0, 30, 0);
            miniMapCamera.lookAt(0, 0, 0);
            
            miniMapRenderer = new THREE.WebGLRenderer({ antialias: true });
            miniMapRenderer.setSize(200, 200);
            miniMapRenderer.domElement.style.width = '200px';
            miniMapRenderer.domElement.style.height = '200px';
            document.getElementById('mini-map').appendChild(miniMapRenderer.domElement);
        }

        function loadAssets() {
            // Load HDR environment
            rgbeLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/4k/industrial_sunset_2k.hdr', function(texture) {
                environmentMap = texture;
                environmentMap.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = environmentMap;
                scene.background = environmentMap;
                assetLoaded();
            });

            // Load textures
            const textures = [
                { name: 'floor', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/hardwood2_diffuse.jpg' },
                { name: 'floorNormal', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/hardwood2_normal.jpg' },
                { name: 'floorRoughness', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/hardwood2_roughness.jpg' },
                { name: 'wall', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg' },
                { name: 'wallNormal', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_normal.jpg' },
                { name: 'wallRoughness', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_roughness.jpg' },
                { name: 'rug', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/carpet.jpg' },
                { name: 'painting', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/painting.jpg' },
                { name: 'fabric', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/fabric.jpg' },
                { name: 'metal', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal_plate.jpg' },
                { name: 'metalNormal', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal_plate_normal.jpg' },
                { name: 'wood', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/wood_diffuse.jpg' },
                { name: 'woodNormal', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/wood_normal.jpg' },
                { name: 'carpet', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/carpet.jpg' },
                { name: 'tiles', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terracotta_diffuse.jpg' },
                { name: 'tilesNormal', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terracotta_normal.jpg' },
                { name: 'ceiling', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/plaster_diffuse.jpg' },
                { name: 'curtain', url: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/curtain.jpg' }
            ];

            textures.forEach(texture => {
                textureLoader.load(texture.url, function(tex) {
                    if (texture.name.includes('Normal')) {
                        tex.encoding = THREE.LinearEncoding;
                    } else {
                        tex.encoding = THREE.sRGBEncoding;
                    }
                    window[texture.name + 'Texture'] = tex;
                    assetLoaded();
                });
            });

            // Load decal material
            decalMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.7,
                metalness: 0.5,
                normalMap: metalNormalTexture,
                normalScale: new THREE.Vector2(0.5, 0.5)
            });
            assetLoaded();

            // Load sounds
            loadSounds();
        }

        function loadSounds() {
            // In a real app, you would use Howler.js or similar for better audio
            footstepSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-hard-floor-2580.mp3');
            footstepSound.loop = true;
            footstepSound.volume = 0.3;
            
            ambientSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-rain-and-thunder-storm-2390.mp3');
            ambientSound.loop = true;
            ambientSound.volume = 0.2;
            
            // Count as loaded
            assetLoaded();
            assetLoaded();
        }

        function assetLoaded() {
            loadedAssets++;
            document.getElementById('progress').style.width = `${(loadedAssets / totalAssets) * 100}%`;
            
            if (loadedAssets === totalAssets) {
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = 0;
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                        setupScene();
                    }, 300);
                }, 500);
            }
        }

        function setupScene() {
            // Setup lighting
            setupLighting();

            // Create rooms
            createLivingRoom();
            createBedroom();
            createHallway();

            // Add furniture
            addFurniture();

            // Add decorative elements
            addDecorations();

            // Setup post-processing
            setupPostProcessing();

            // Setup controls
            setupControls();

            // Event listeners
            setupEventListeners();

            // Start ambient sound
            if (soundEnabled) {
                ambientSound.play();
            }

            // Start animation loop
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Directional light (sun)
            directionalLight = new THREE.DirectionalLight(0xfff4e6, 1.2);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.bias = -0.0001;
            scene.add(directionalLight);

            // Point light 1 (living room lamp)
            pointLight1 = new THREE.PointLight(0xffeedd, 2, 8, 2);
            pointLight1.position.set(0, 2.5, -3);
            pointLight1.castShadow = true;
            pointLight1.shadow.mapSize.width = 2048;
            pointLight1.shadow.mapSize.height = 2048;
            pointLight1.shadow.camera.near = 0.1;
            pointLight1.shadow.camera.far = 20;
            scene.add(pointLight1);

            // Point light 2 (bedroom lamp)
            pointLight2 = new THREE.PointLight(0xffddbb, 1.8, 6, 2);
            pointLight2.position.set(8, 2, 8);
            pointLight2.castShadow = true;
            scene.add(pointLight2);

            // Window light
            const windowLight = new THREE.RectAreaLight(0x88ccee, 2, 4, 3);
            windowLight.position.set(-livingRoomWidth/2 - 1, 2, -2);
            windowLight.rotation.y = Math.PI/2;
            scene.add(windowLight);
        }

        function createLivingRoom() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(livingRoomWidth, livingRoomDepth);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: floorTexture,
                normalMap: floorNormalTexture,
                roughnessMap: floorRoughnessTexture,
                roughness: 0.8,
                metalness: 0.1,
                envMap: environmentMap,
                envMapIntensity: 0.2
            });
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(livingRoomWidth/2, livingRoomDepth/2);
            floorNormalTexture.wrapS = THREE.RepeatWrapping;
            floorNormalTexture.wrapT = THREE.RepeatWrapping;
            floorNormalTexture.repeat.set(livingRoomWidth/2, livingRoomDepth/2);
            floorRoughnessTexture.wrapS = THREE.RepeatWrapping;
            floorRoughnessTexture.wrapT = THREE.RepeatWrapping;
            floorRoughnessTexture.repeat.set(livingRoomWidth/2, livingRoomDepth/2);

            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(0, 0, -livingRoomDepth/2);
            floor.receiveShadow = true;
            scene.add(floor);
            objects.push(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: wallTexture,
                normalMap: wallNormalTexture,
                roughnessMap: wallRoughnessTexture,
                roughness: 0.6,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.1
            });
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(2, 2);
            wallNormalTexture.wrapS = THREE.RepeatWrapping;
            wallNormalTexture.wrapT = THREE.RepeatWrapping;
            wallNormalTexture.repeat.set(2, 2);
            wallRoughnessTexture.wrapS = THREE.RepeatWrapping;
            wallRoughnessTexture.wrapT = THREE.RepeatWrapping;
            wallRoughnessTexture.repeat.set(2, 2);

            // Left wall
            const leftWallGeometry = new THREE.PlaneGeometry(livingRoomDepth, livingRoomHeight);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-livingRoomWidth/2, livingRoomHeight/2, -livingRoomDepth/2);
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            objects.push(leftWall);

            // Right wall (with doorway to hallway)
            const rightWallGeometry = new THREE.BoxGeometry(livingRoomDepth, livingRoomHeight, 0.2);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.rotation.y = Math.PI / 2;
            rightWall.position.set(livingRoomWidth/2, livingRoomHeight/2, -livingRoomDepth/2);
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            objects.push(rightWall);

            // Front wall
            const frontWallGeometry = new THREE.PlaneGeometry(livingRoomWidth, livingRoomHeight);
            const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
            frontWall.position.set(0, livingRoomHeight/2, -livingRoomDepth);
            frontWall.receiveShadow = true;
            scene.add(frontWall);
            objects.push(frontWall);

            // Back wall (open to hallway)
            const backWallLeftGeometry = new THREE.PlaneGeometry(livingRoomWidth/2 - 1, livingRoomHeight);
            const backWallLeft = new THREE.Mesh(backWallLeftGeometry, wallMaterial);
            backWallLeft.position.set(-livingRoomWidth/4 - 0.5, livingRoomHeight/2, 0);
            backWallLeft.receiveShadow = true;
            scene.add(backWallLeft);
            objects.push(backWallLeft);

            const backWallRightGeometry = new THREE.PlaneGeometry(livingRoomWidth/2 - 1, livingRoomHeight);
            const backWallRight = new THREE.Mesh(backWallRightGeometry, wallMaterial);
            backWallRight.position.set(livingRoomWidth/4 + 0.5, livingRoomHeight/2, 0);
            backWallRight.receiveShadow = true;
            scene.add(backWallRight);
            objects.push(backWallRight);

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(livingRoomWidth, livingRoomDepth);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                map: ceilingTexture,
                roughness: 0.7,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.3
            });
            ceilingTexture.wrapS = THREE.RepeatWrapping;
            ceilingTexture.wrapT = THREE.RepeatWrapping;
            ceilingTexture.repeat.set(2, 2);
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(0, livingRoomHeight, -livingRoomDepth/2);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            objects.push(ceiling);

            // Add baseboards
            const baseboardGeometry = new THREE.BoxGeometry(0.1, 0.15, livingRoomDepth);
            const baseboardMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            
            // Left baseboard
            const leftBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            leftBaseboard.position.set(-livingRoomWidth/2 + 0.05, 0.075, -livingRoomDepth/2);
            scene.add(leftBaseboard);
            
            // Right baseboard
            const rightBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            rightBaseboard.position.set(livingRoomWidth/2 - 0.05, 0.075, -livingRoomDepth/2);
            scene.add(rightBaseboard);
            
            // Front baseboard
            const frontBaseboard = new THREE.Mesh(new THREE.BoxGeometry(livingRoomWidth, 0.15, 0.1), baseboardMaterial);
            frontBaseboard.position.set(0, 0.075, -livingRoomDepth + 0.05);
            scene.add(frontBaseboard);
            
            // Back baseboard left
            const backBaseboardLeft = new THREE.Mesh(new THREE.BoxGeometry(livingRoomWidth/2 - 1, 0.15, 0.1), baseboardMaterial);
            backBaseboardLeft.position.set(-livingRoomWidth/4 - 0.5, 0.075, 0.05);
            scene.add(backBaseboardLeft);
            
            // Back baseboard right
            const backBaseboardRight = new THREE.Mesh(new THREE.BoxGeometry(livingRoomWidth/2 - 1, 0.15, 0.1), baseboardMaterial);
            backBaseboardRight.position.set(livingRoomWidth/4 + 0.5, 0.075, 0.05);
            scene.add(backBaseboardRight);
        }

        function createBedroom() {
            // Floor (carpet)
            const floorGeometry = new THREE.PlaneGeometry(bedroomWidth, bedroomDepth);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: carpetTexture,
                roughness: 0.9,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.1
            });
            carpetTexture.wrapS = THREE.RepeatWrapping;
            carpetTexture.wrapT = THREE.RepeatWrapping;
            carpetTexture.repeat.set(bedroomWidth/3, bedroomDepth/3);

            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(livingRoomWidth/2 + hallwayWidth/2, 0, bedroomDepth/2 + hallwayLength);
            floor.receiveShadow = true;
            scene.add(floor);
            objects.push(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                roughness: 0.5,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.1
            });

            // Left wall (with window)
            const leftWallGeometry = new THREE.PlaneGeometry(bedroomDepth, bedroomHeight);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(livingRoomWidth/2 + hallwayWidth, bedroomHeight/2, bedroomDepth/2 + hallwayLength);
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            objects.push(leftWall);

            // Right wall (shared with hallway)
            const rightWallGeometry = new THREE.BoxGeometry(bedroomDepth, bedroomHeight, 0.2);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.rotation.y = Math.PI / 2;
            rightWall.position.set(livingRoomWidth/2, bedroomHeight/2, bedroomDepth/2 + hallwayLength);
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            objects.push(rightWall);

            // Front wall (with door)
            const frontWallGeometry = new THREE.PlaneGeometry(bedroomWidth, bedroomHeight);
            const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
            frontWall.position.set(livingRoomWidth/2 + hallwayWidth/2, bedroomHeight/2, bedroomDepth + hallwayLength);
            frontWall.receiveShadow = true;
            scene.add(frontWall);
            objects.push(frontWall);

            // Back wall (partial)
            const backWallLeftGeometry = new THREE.PlaneGeometry(bedroomWidth/2 - 0.8, bedroomHeight);
            const backWallLeft = new THREE.Mesh(backWallLeftGeometry, wallMaterial);
            backWallLeft.position.set(livingRoomWidth/2 + hallwayWidth/4 - 0.4, bedroomHeight/2, hallwayLength);
            backWallLeft.receiveShadow = true;
            scene.add(backWallLeft);
            objects.push(backWallLeft);

            const backWallRightGeometry = new THREE.PlaneGeometry(bedroomWidth/2 - 0.8, bedroomHeight);
            const backWallRight = new THREE.Mesh(backWallRightGeometry, wallMaterial);
            backWallRight.position.set(livingRoomWidth/2 + hallwayWidth/2 + bedroomWidth/4 + 0.4, bedroomHeight/2, hallwayLength);
            backWallRight.receiveShadow = true;
            scene.add(backWallRight);
            objects.push(backWallRight);

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(bedroomWidth, bedroomDepth);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                map: ceilingTexture,
                roughness: 0.7,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.3
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(livingRoomWidth/2 + hallwayWidth/2, bedroomHeight, bedroomDepth/2 + hallwayLength);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            objects.push(ceiling);

            // Window
            createWindow(
                livingRoomWidth/2 + hallwayWidth + 0.1, 
                1.5, 
                bedroomDepth/2 + hallwayLength - 1,
                2, 1.5
            );

            // Door frame
            createDoorFrame(
                livingRoomWidth/2 + hallwayWidth/2,
                0,
                hallwayLength,
                1, 2.2, 0.2
            );
        }

        function createHallway() {
            // Floor (tiles)
            const floorGeometry = new THREE.PlaneGeometry(hallwayWidth, hallwayLength);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: tilesTexture,
                normalMap: tilesNormalTexture,
                roughness: 0.4,
                metalness: 0.1,
                envMap: environmentMap,
                envMapIntensity: 0.2
            });
            tilesTexture.wrapS = THREE.RepeatWrapping;
            tilesTexture.wrapT = THREE.RepeatWrapping;
            tilesTexture.repeat.set(hallwayWidth, hallwayLength/0.3);
            tilesNormalTexture.wrapS = THREE.RepeatWrapping;
            tilesNormalTexture.wrapT = THREE.RepeatWrapping;
            tilesNormalTexture.repeat.set(hallwayWidth, hallwayLength/0.3);

            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(livingRoomWidth/2, 0, hallwayLength/2);
            floor.receiveShadow = true;
            scene.add(floor);
            objects.push(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                roughness: 0.5,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.1
            });

            // Left wall (shared with living room)
            const leftWallGeometry = new THREE.PlaneGeometry(hallwayLength, hallwayHeight);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(livingRoomWidth/2 - 0.1, hallwayHeight/2, hallwayLength/2);
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            objects.push(leftWall);

            // Right wall (shared with bedroom)
            const rightWallGeometry = new THREE.PlaneGeometry(hallwayLength, hallwayHeight);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.rotation.y = Math.PI / 2;
            rightWall.position.set(livingRoomWidth/2 + hallwayWidth + 0.1, hallwayHeight/2, hallwayLength/2);
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            objects.push(rightWall);

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(hallwayWidth, hallwayLength);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                map: ceilingTexture,
                roughness: 0.7,
                metalness: 0.0,
                envMap: environmentMap,
                envMapIntensity: 0.3
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(livingRoomWidth/2, hallwayHeight, hallwayLength/2);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            objects.push(ceiling);
        }

        function createWindow(x, y, z, width, height) {
            // Window frame
            const frameGeometry = new THREE.BoxGeometry(width + 0.1, height + 0.1, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.4,
                metalness: 0.3,
                envMap: environmentMap
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(x, y, z);
            frame.castShadow = true;
            scene.add(frame);

            // Window glass
            const glassGeometry = new THREE.PlaneGeometry(width, height);
            const glassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x88ccff,
                roughness: 0.1,
                metalness: 0.3,
                transparent: true,
                opacity: 0.7,
                envMap: environmentMap
            });
            const glass = new THREE.Mesh(glassGeometry, glassMaterial);
            glass.position.set(x, y, z - 0.05);
            scene.add(glass);

            // Curtain
            const curtainGeometry = new THREE.PlaneGeometry(width * 1.5, height * 1.2);
            const curtainMaterial = new THREE.MeshStandardMaterial({ 
                map: curtainTexture,
                roughness: 0.9,
                metalness: 0.0,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8,
                envMap: environmentMap
            });
            curtainTexture.wrapS = THREE.RepeatWrapping;
            curtainTexture.wrapT = THREE.RepeatWrapping;
            curtainTexture.repeat.set(1, 1);
            
            const curtain = new THREE.Mesh(curtainGeometry, curtainMaterial);
            curtain.position.set(x + width/2 + 0.2, y, z - 0.02);
            curtain.castShadow = true;
            scene.add(curtain);
        }

        function createDoorFrame(x, y, z, width, height, depth) {
            // Door frame
            const frameGeometry = new THREE.BoxGeometry(width, height, depth);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.4,
                metalness: 0.3,
                envMap: environmentMap
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(x, y + height/2, z);
            frame.castShadow = true;
            scene.add(frame);
            collidableObjects.push(frame);

            // Door
            const doorGeometry = new THREE.BoxGeometry(width - 0.1, height - 0.2, depth/2);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.3,
                metalness: 0.2,
                envMap: environmentMap
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(x, y + (height - 0.2)/2, z - depth/4);
            door.castShadow = true;
            scene.add(door);
            collidableObjects.push(door);
        }

        function addFurniture() {
            // Create a detailed sofa
            function createSofa(x, z, rotationY = 0) {
                // Sofa base
                const baseGeometry = new THREE.BoxGeometry(2, 0.8, 1);
                const baseMaterial = new THREE.MeshStandardMaterial({ 
                    map: fabricTexture,
                    roughness: 0.9,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(x, 0.4, z);
                base.rotation.y = rotationY;
                base.castShadow = true;
                base.receiveShadow = true;
                scene.add(base);
                collidableObjects.push(base);

                // Sofa back
                const backGeometry = new THREE.BoxGeometry(2, 0.8, 0.1);
                const back = new THREE.Mesh(backGeometry, baseMaterial);
                back.position.set(x, 0.8, z + (rotationY === 0 ? 0.45 : -0.45));
                back.rotation.y = rotationY;
                back.castShadow = true;
                back.receiveShadow = true;
                scene.add(back);

                // Sofa arms
                const armGeometry = new THREE.BoxGeometry(0.2, 0.6, 1);
                const leftArm = new THREE.Mesh(armGeometry, baseMaterial);
                leftArm.position.set(x - 0.9, 0.5, z);
                leftArm.rotation.y = rotationY;
                leftArm.castShadow = true;
                leftArm.receiveShadow = true;
                scene.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, baseMaterial);
                rightArm.position.set(x + 0.9, 0.5, z);
                rightArm.rotation.y = rotationY;
                rightArm.castShadow = true;
                rightArm.receiveShadow = true;
                scene.add(rightArm);

                // Sofa cushions
                const cushionGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.6);
                const cushionMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B0000,
                    roughness: 0.8,
                    metalness: 0.0,
                    envMap: environmentMap
                });

                for (let i = 0; i < 3; i++) {
                    const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
                    cushion.position.set(x - 0.6 + i * 0.6, 0.7, z + (rotationY === 0 ? 0.2 : -0.2));
                    cushion.rotation.y = rotationY;
                    cushion.castShadow = true;
                    cushion.receiveShadow = true;
                    scene.add(cushion);
                }

                return base;
            }

            // Create a detailed bed
            function createBed(x, z, rotationY = 0) {
                // Bed frame
                const frameGeometry = new THREE.BoxGeometry(2, 0.4, 1.8);
                const frameMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    normalMap: woodNormalTexture,
                    roughness: 0.6,
                    metalness: 0.1,
                    envMap: environmentMap
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(x, 0.2, z);
                frame.rotation.y = rotationY;
                frame.castShadow = true;
                frame.receiveShadow = true;
                scene.add(frame);
                collidableObjects.push(frame);

                // Mattress
                const mattressGeometry = new THREE.BoxGeometry(1.9, 0.3, 1.7);
                const mattressMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.8,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const mattress = new THREE.Mesh(mattressGeometry, mattressMaterial);
                mattress.position.set(x, 0.45, z);
                mattress.rotation.y = rotationY;
                mattress.castShadow = true;
                mattress.receiveShadow = true;
                scene.add(mattress);

                // Pillows
                const pillowGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.4);
                const pillowMaterial = new THREE.MeshStandardMaterial({ 
                    map: fabricTexture,
                    roughness: 0.7,
                    metalness: 0.0,
                    envMap: environmentMap
                });

                const pillow1 = new THREE.Mesh(pillowGeometry, pillowMaterial);
                pillow1.position.set(x - 0.4, 0.6, z + (rotationY === 0 ? 0.6 : -0.6));
                pillow1.rotation.y = rotationY;
                pillow1.castShadow = true;
                pillow1.receiveShadow = true;
                scene.add(pillow1);

                const pillow2 = new THREE.Mesh(pillowGeometry, pillowMaterial);
                pillow2.position.set(x + 0.4, 0.6, z + (rotationY === 0 ? 0.6 : -0.6));
                pillow2.rotation.y = rotationY;
                pillow2.castShadow = true;
                pillow2.receiveShadow = true;
                scene.add(pillow2);

                // Blanket
                const blanketGeometry = new THREE.BoxGeometry(1.8, 0.05, 1.2);
                const blanketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4682B4,
                    roughness: 0.9,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const blanket = new THREE.Mesh(blanketGeometry, blanketMaterial);
                blanket.position.set(x, 0.5, z + (rotationY === 0 ? -0.2 : 0.2));
                blanket.rotation.y = rotationY;
                blanket.castShadow = true;
                blanket.receiveShadow = true;
                scene.add(blanket);

                return frame;
            }

            // Create a detailed table
            function createTable(x, z, rotationY = 0) {
                // Table top
                const tableTopGeometry = new THREE.BoxGeometry(1.2, 0.08, 0.8);
                const tableTopMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    normalMap: woodNormalTexture,
                    roughness: 0.7,
                    metalness: 0.1,
                    envMap: environmentMap
                });
                const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
                tableTop.position.set(x, 0.74, z);
                tableTop.rotation.y = rotationY;
                tableTop.castShadow = true;
                tableTop.receiveShadow = true;
                scene.add(tableTop);
                collidableObjects.push(tableTop);

                // Table legs
                const legGeometry = new THREE.CylinderGeometry(0.04, 0.05, 0.7, 16);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.4,
                    metalness: 0.8,
                    envMap: environmentMap
                });
                
                const legPositions = [
                    [x - 0.5, 0.35, z - 0.3],
                    [x - 0.5, 0.35, z + 0.3],
                    [x + 0.5, 0.35, z - 0.3],
                    [x + 0.5, 0.35, z + 0.3]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.rotation.y = rotationY;
                    leg.castShadow = true;
                    leg.receiveShadow = true;
                    scene.add(leg);
                });

                // Add some decals to the table
                addDecal(tableTop, new THREE.Vector3(x, 0.78, z), new THREE.Euler(0, rotationY, 0), new THREE.Vector3(0.4, 0.1, 0.3));

                return tableTop;
            }

            // Create a detailed chair
            function createChair(x, z, rotationY = 0) {
                // Chair seat
                const seatGeometry = new THREE.BoxGeometry(0.5, 0.08, 0.5);
                const seatMaterial = new THREE.MeshStandardMaterial({ 
                    map: fabricTexture,
                    roughness: 0.9,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(x, 0.4, z);
                seat.rotation.y = rotationY;
                seat.castShadow = true;
                seat.receiveShadow = true;
                scene.add(seat);
                collidableObjects.push(seat);

                // Chair legs
                const legGeometry = new THREE.CylinderGeometry(0.02, 0.03, 0.4, 12);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    roughness: 0.3,
                    metalness: 0.9,
                    envMap: environmentMap
                });
                
                const legPositions = [
                    [x - 0.2, 0.2, z - 0.2],
                    [x - 0.2, 0.2, z + 0.2],
                    [x + 0.2, 0.2, z - 0.2],
                    [x + 0.2, 0.2, z + 0.2]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.rotation.y = rotationY;
                    leg.castShadow = true;
                    leg.receiveShadow = true;
                    scene.add(leg);
                });

                // Chair back
                const backGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.05);
                const backMaterial = new THREE.MeshStandardMaterial({ 
                    map: fabricTexture,
                    roughness: 0.9,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const back = new THREE.Mesh(backGeometry, backMaterial);
                back.position.set(x, 0.65, z + (rotationY === 0 ? 0.25 : -0.25));
                back.rotation.y = rotationY;
                back.castShadow = true;
                back.receiveShadow = true;
                scene.add(back);

                return seat;
            }

            // Create a wardrobe
            function createWardrobe(x, z, rotationY = 0) {
                // Wardrobe body
                const bodyGeometry = new THREE.BoxGeometry(1.2, 2, 0.6);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    normalMap: woodNormalTexture,
                    roughness: 0.6,
                    metalness: 0.1,
                    envMap: environmentMap
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(x, 1, z);
                body.rotation.y = rotationY;
                body.castShadow = true;
                body.receiveShadow = true;
                scene.add(body);
                collidableObjects.push(body);

                // Wardrobe doors
                const doorGeometry = new THREE.BoxGeometry(0.6, 1.9, 0.05);
                const doorMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    normalMap: woodNormalTexture,
                    roughness: 0.5,
                    metalness: 0.2,
                    envMap: environmentMap
                });

                const door1 = new THREE.Mesh(doorGeometry, doorMaterial);
                door1.position.set(x - 0.3, 1, z + 0.3);
                door1.rotation.y = rotationY;
                door1.castShadow = true;
                door1.receiveShadow = true;
                scene.add(door1);

                const door2 = new THREE.Mesh(doorGeometry, doorMaterial);
                door2.position.set(x + 0.3, 1, z + 0.3);
                door2.rotation.y = rotationY;
                door2.castShadow = true;
                door2.receiveShadow = true;
                scene.add(door2);

                // Wardrobe handles
                const handleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 12);
                const handleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x888888,
                    roughness: 0.3,
                    metalness: 0.9,
                    envMap: environmentMap
                });

                const handle1 = new THREE.Mesh(handleGeometry, handleMaterial);
                handle1.position.set(x - 0.5, 1, z + 0.32);
                handle1.rotation.z = Math.PI/2;
                handle1.castShadow = true;
                scene.add(handle1);

                const handle2 = new THREE.Mesh(handleGeometry, handleMaterial);
                handle2.position.set(x + 0.5, 1, z + 0.32);
                handle2.rotation.z = Math.PI/2;
                handle2.castShadow = true;
                scene.add(handle2);

                return body;
            }

            // Create furniture in living room
            createSofa(0, -3);
            createTable(0, -5);
            createChair(-0.8, -5.8, 0);
            createChair(0.8, -5.8, 0);
            createChair(0, -4.2, Math.PI);

            // Create furniture in bedroom
            createBed(livingRoomWidth/2 + hallwayWidth/2 + 2, hallwayLength + 4, Math.PI/2);
            createWardrobe(livingRoomWidth/2 + hallwayWidth/2 - 2, hallwayLength + 4, Math.PI/2);
            createTable(livingRoomWidth/2 + hallwayWidth/2, hallwayLength + 2);
            createChair(livingRoomWidth/2 + hallwayWidth/2 + 0.5, hallwayLength + 2.5, Math.PI);
        }

        function addDecorations() {
            // Add a rug in living room
            const rugGeometry = new THREE.PlaneGeometry(5, 3);
            const rugMaterial = new THREE.MeshStandardMaterial({ 
                map: rugTexture,
                roughness: 0.9,
                metalness: 0.0,
                side: THREE.DoubleSide,
                envMap: environmentMap
            });
            rugTexture.wrapS = THREE.RepeatWrapping;
            rugTexture.wrapT = THREE.RepeatWrapping;
            rugTexture.repeat.set(2, 2);

            const rug = new THREE.Mesh(rugGeometry, rugMaterial);
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(0, 0.01, -4);
            rug.receiveShadow = true;
            scene.add(rug);

            // Add a painting on the wall in living room
            const paintingGeometry = new THREE.PlaneGeometry(2.5, 1.8);
            const paintingMaterial = new THREE.MeshStandardMaterial({ 
                map: paintingTexture,
                roughness: 0.2,
                metalness: 0.0,
                envMap: environmentMap
            });
            const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
            painting.position.set(0, 2.2, -livingRoomDepth + 0.01);
            scene.add(painting);

            // Add frame to painting
            const frameGeometry = new THREE.BoxGeometry(2.6, 1.9, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.4,
                metalness: 0.3,
                envMap: environmentMap
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 2.2, -livingRoomDepth + 0.06);
            frame.castShadow = true;
            scene.add(frame);

            // Add a detailed lamp in living room
            const lampBaseGeometry = new THREE.CylinderGeometry(0.12, 0.2, 0.2, 32);
            const lampBaseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.3,
                metalness: 0.8,
                envMap: environmentMap
            });
            const lampBase = new THREE.Mesh(lampBaseGeometry, lampBaseMaterial);
            lampBase.position.set(0, 0.1, -3);
            lampBase.castShadow = true;
            scene.add(lampBase);

            const lampPoleGeometry = new THREE.CylinderGeometry(0.025, 0.025, 1.8, 32);
            const lampPole = new THREE.Mesh(lampPoleGeometry, lampBaseMaterial);
            lampPole.position.set(0, 1, -3);
            lampPole.castShadow = true;
            scene.add(lampPole);

            const lampShadeGeometry = new THREE.ConeGeometry(0.6, 0.4, 32);
            const lampShadeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.7,
                metalness: 0.0,
                transparent: true,
                opacity: 0.6,
                envMap: environmentMap
            });
            const lampShade = new THREE.Mesh(lampShadeGeometry, lampShadeMaterial);
            lampShade.position.set(0, 1.8, -3);
            lampShade.rotation.x = Math.PI;
            lampShade.castShadow = true;
            scene.add(lampShade);

            // Add a nightstand in bedroom
            function createNightstand(x, z) {
                // Table top
                const topGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.5);
                const topMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    normalMap: woodNormalTexture,
                    roughness: 0.6,
                    metalness: 0.1,
                    envMap: environmentMap
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.set(x, 0.5, z);
                top.castShadow = true;
                top.receiveShadow = true;
                scene.add(top);

                // Drawer
                const drawerGeometry = new THREE.BoxGeometry(0.45, 0.3, 0.45);
                const drawerMaterial = new THREE.MeshStandardMaterial({ 
                    map: woodTexture,
                    normalMap: woodNormalTexture,
                    roughness: 0.7,
                    metalness: 0.1,
                    envMap: environmentMap
                });
                const drawer = new THREE.Mesh(drawerGeometry, drawerMaterial);
                drawer.position.set(x, 0.25, z);
                drawer.castShadow = true;
                drawer.receiveShadow = true;
                scene.add(drawer);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 12);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.4,
                    metalness: 0.8,
                    envMap: environmentMap
                });

                const legPositions = [
                    [x - 0.2, 0.1, z - 0.2],
                    [x - 0.2, 0.1, z + 0.2],
                    [x + 0.2, 0.1, z - 0.2],
                    [x + 0.2, 0.1, z + 0.2]
                ];

                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    leg.receiveShadow = true;
                    scene.add(leg);
                });

                // Handle
                const handleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 12);
                const handle = new THREE.Mesh(handleGeometry, legMaterial);
                handle.position.set(x, 0.25, z + 0.23);
                handle.rotation.z = Math.PI/2;
                handle.castShadow = true;
                scene.add(handle);

                collidableObjects.push(top);
                return top;
            }

            createNightstand(livingRoomWidth/2 + hallwayWidth/2 + 1.5, hallwayLength + 3.5);
            createNightstand(livingRoomWidth/2 + hallwayWidth/2 + 1.5, hallwayLength + 4.5);

            // Add some books on nightstand
            function createBook(x, y, z, width, height, depth, rotationY, color) {
                const bookGeometry = new THREE.BoxGeometry(width, height, depth);
                const bookMaterial = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.6,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const book = new THREE.Mesh(bookGeometry, bookMaterial);
                book.position.set(x, y, z);
                book.rotation.y = rotationY;
                book.castShadow = true;
                book.receiveShadow = true;
                scene.add(book);
                collidableObjects.push(book);
                return book;
            }

            // Books on nightstand
            createBook(livingRoomWidth/2 + hallwayWidth/2 + 1.5, 0.53, hallwayLength + 3.6, 0.15, 0.02, 0.1, 0.5, 0x8B0000);
            createBook(livingRoomWidth/2 + hallwayWidth/2 + 1.5, 0.55, hallwayLength + 3.5, 0.16, 0.025, 0.12, 0.3, 0x006400);
            createBook(livingRoomWidth/2 + hallwayWidth/2 + 1.5, 0.57, hallwayLength + 3.4, 0.14, 0.03, 0.11, 0.1, 0x00008B);

            // Add a plant in bedroom
            function createPlant(x, z) {
                const potGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 32);
                const potMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.6,
                    metalness: 0.1,
                    envMap: environmentMap
                });
                const pot = new THREE.Mesh(potGeometry, potMaterial);
                pot.position.set(x, 0.1, z);
                pot.castShadow = true;
                pot.receiveShadow = true;
                scene.add(pot);

                // Leaves
                const leavesGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const leavesMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22,
                    roughness: 0.9,
                    metalness: 0.0,
                    envMap: environmentMap
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, 0.4, z);
                leaves.castShadow = true;
                scene.add(leaves);

                collidableObjects.push(pot);
                return pot;
            }

            createPlant(livingRoomWidth/2 + hallwayWidth/2 - 1, hallwayLength + 2);
        }

        function addDecal(mesh, position, rotation, scale) {
            const decalGeometry = new THREE.DecalGeometry(
                mesh,
                position,
                rotation,
                scale
            );
            
            const decal = new THREE.Mesh(decalGeometry, decalMaterial);
            scene.add(decal);
        }

        function setupPostProcessing() {
            // Create composer
            composer = new THREE.EffectComposer(renderer);
            composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Add render pass
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Add bloom pass
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0;
            bloomPass.strength = 0.7;
            bloomPass.radius = 1.0;
            composer.addPass(bloomPass);
            
            // Add FXAA pass
            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.material.uniforms['resolution'].value.set(
                1 / (window.innerWidth * renderer.getPixelRatio()),
                1 / (window.innerHeight * renderer.getPixelRatio())
            );
            composer.addPass(fxaaPass);
        }

        function setupControls() {
            // Pointer lock controls
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            
            // Event listener for pointer lock change
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    controls.isLocked = true;
                    document.getElementById('ui').style.opacity = 0;
                    
                    // Start footstep sound when moving
                    if (soundEnabled && (moveForward || moveBackward || moveLeft || moveRight)) {
                        footstepSound.play();
                    }
                } else {
                    controls.isLocked = false;
                    document.getElementById('ui').style.opacity = 1;
                    footstepSound.pause();
                }
            }, false);
            
            // Event listener for clicking to lock
            renderer.domElement.addEventListener('click', () => {
                if (!controls.isLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            // Key event listeners
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }

        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Escape key to show/hide UI
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    if (controls.isLocked) {
                        document.exitPointerLock();
                    } else {
                        renderer.domElement.requestPointerLock();
                    }
                }
            });

            // Sound toggle button
            document.getElementById('sound-toggle').addEventListener('click', toggleSound);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const button = document.getElementById('sound-toggle');
            
            if (soundEnabled) {
                button.textContent = 'ðŸ”Š Sound ON';
                ambientSound.play();
                if (controls.isLocked && (moveForward || moveBackward || moveLeft || moveRight)) {
                    footstepSound.play();
                }
            } else {
                button.textContent = 'ðŸ”‡ Sound OFF';
                ambientSound.pause();
                footstepSound.pause();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Update FXAA pass
            fxaaPass.material.uniforms['resolution'].value.set(
                1 / (window.innerWidth * renderer.getPixelRatio()),
                1 / (window.innerHeight * renderer.getPixelRatio())
            );
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y = 0.15; canJump = false; } break;
                case 'ShiftLeft': isRunning = true; break;
            }

            // Play footstep sound when starting to move
            if (soundEnabled && controls.isLocked && !footstepSound.paused && 
                (moveForward || moveBackward || moveLeft || moveRight)) {
                footstepSound.play();
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; break;
            }

            // Stop footstep sound when not moving
            if (!moveForward && !moveBackward && !moveLeft && !moveRight) {
                footstepSound.pause();
            }
        }

        function checkCollisions(newPosition) {
            // Simple boundary checks
            const buffer = 0.5;
            
            // Living room boundaries
            if (newPosition.z < -livingRoomDepth + buffer && 
                (newPosition.x < -livingRoomWidth/2 + buffer || 
                 newPosition.x > livingRoomWidth/2 - buffer)) {
                return true;
            }
            
            if (newPosition.z > 0 - buffer && newPosition.z < hallwayLength + buffer) {
                // Hallway boundaries
                if (newPosition.x < livingRoomWidth/2 - buffer || 
                    newPosition.x > livingRoomWidth/2 + hallwayWidth - buffer) {
                    return true;
                }
            } else if (newPosition.z > hallwayLength + buffer) {
                // Bedroom boundaries
                if (newPosition.x < livingRoomWidth/2 + buffer || 
                    newPosition.x > livingRoomWidth/2 + hallwayWidth - buffer ||
                    newPosition.z > hallwayLength + bedroomDepth - buffer) {
                    return true;
                }
            }
            
            // Check furniture collisions
            for (const object of collidableObjects) {
                const objectBox = new THREE.Box3().setFromObject(object);
                objectBox.expandByScalar(0.5); // Add some buffer
                
                if (objectBox.containsPoint(newPosition)) {
                    return true;
                }
            }
            
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = time - prevTime;
            prevTime = time;
            
            // Update lamp light intensity
            pointLight1.intensity = 1.5 + Math.sin(time * 2) * 0.3;
            pointLight2.intensity = 1.2 + Math.sin(time * 2.3) * 0.2;
            
            // Update player movement
            if (controls.isLocked) {
                const speed = isRunning ? 0.0025 : 0.0015;
                const actualSpeed = delta * 1000 * speed;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 0.5 * delta; // 0.5 because we're not making a full physics game
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                
                if (moveForward || moveBackward) velocity.z -= direction.z * actualSpeed;
                if (moveLeft || moveRight) velocity.x -= direction.x * actualSpeed;
                
                // Check collisions before moving
                const oldPosition = camera.position.clone();
                controls.moveRight(-velocity.x);
                controls.moveForward(-velocity.z);
                
                if (checkCollisions(camera.position)) {
                    camera.position.copy(oldPosition);
                }
                
                // Vertical movement (jumping/falling)
                const oldY = camera.position.y;
                camera.position.y += velocity.y;
                
                // Check if on ground
                if (camera.position.y < 1.6) {
                    camera.position.y = 1.6;
                    velocity.y = 0;
                    canJump = true;
                }

                // Update footstep sound speed
                if (soundEnabled) {
                    footstepSound.playbackRate = isRunning ? 1.5 : 1.0;
                }
            }
            
            // Update mini-map
            updateMiniMap();
            
            // Update post-processing
            composer.render();
        }

        function updateMiniMap() {
            // Update mini-map camera to follow player
            miniMapCamera.position.set(camera.position.x, 30, camera.position.z);
            miniMapCamera.lookAt(camera.position.x, 0, camera.position.z);
            
            // Render mini-map
            miniMapRenderer.render(scene, miniMapCamera);
            
            // Draw player indicator
            const ctx = miniMapRenderer.domElement.getContext('2d');
            ctx.clearRect(0, 0, 200, 200);
            
            // Draw player direction indicator
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(100, 100, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw direction line
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(100, 100);
            
            // Calculate direction based on camera rotation
            const angle = camera.rotation.y;
            const length = 15;
            ctx.lineTo(
                100 + Math.sin(angle) * length,
                100 - Math.cos(angle) * length
            );
            ctx.stroke();
        }
    </script>
</body>
</html>