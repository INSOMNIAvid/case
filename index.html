<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Room Walkthrough</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        canvas { 
            display: block; 
            outline: none;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            max-width: 250px;
            line-height: 1.5;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0,0,0,0.8);
            padding: 12px 25px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: flex;
            gap: 15px;
            pointer-events: none;
        }
        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .key {
            background-color: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 5px 8px;
            margin-top: 5px;
            min-width: 30px;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 18px;
            z-index: 1000;
            transition: opacity 1s;
        }
        #progress {
            width: 200px;
            height: 3px;
            background: rgba(255,255,255,0.2);
            margin-top: 20px;
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading Enhanced 3D Environment...</div>
        <div id="progress"><div id="progress-bar"></div></div>
    </div>
    <div id="info">Enhanced 3D Room Walkthrough<br>WASD: Move | SPACE: Jump | SHIFT: Sprint | Mouse: Look around</div>
    <div id="controls">
        <div class="control-item">
            <div>Move</div>
            <div class="key">WASD</div>
        </div>
        <div class="control-item">
            <div>Jump</div>
            <div class="key">SPACE</div>
        </div>
        <div class="control-item">
            <div>Sprint</div>
            <div class="key">SHIFT</div>
        </div>
        <div class="control-item">
            <div>Look</div>
            <div class="key">MOUSE</div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/FirstPersonControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // Show loading screen
        const loadingScreen = document.getElementById('loading');
        const progressBar = document.getElementById('progress-bar');
        
        // Track loading progress
        let assetsLoaded = 0;
        const totalAssets = 10; // Adjust based on actual assets
        
        function updateProgress() {
            assetsLoaded++;
            const progress = Math.min(100, (assetsLoaded / totalAssets) * 100);
            progressBar.style.width = `${progress}%`;
            
            if (assetsLoaded >= totalAssets) {
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 1000);
                }, 500);
            }
        }
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.0015);
        
        // Improved camera with dynamic FOV
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);
        
        // Enhanced renderer with better quality settings
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap at 1.5 for performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);
        
        // Post-processing pipeline
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        // Bloom effect for lights
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.2, // strength
            0.4, // radius
            0.8 // threshold
        );
        composer.addPass(bloomPass);
        
        // Outline effect for potential interaction highlighting
        const outlinePass = new THREE.OutlinePass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            scene,
            camera
        );
        outlinePass.edgeStrength = 4.0;
        outlinePass.edgeGlow = 0.8;
        outlinePass.edgeThickness = 1.2;
        outlinePass.pulsePeriod = 2;
        outlinePass.visibleEdgeColor.set('#ffffff');
        outlinePass.hiddenEdgeColor.set('#190a05');
        composer.addPass(outlinePass);
        
        // FXAA for smoother edges
        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(fxaaPass);
        
        // Lighting setup - more realistic and dynamic
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        updateProgress();
        
        // Main directional light (sun/moon)
        const directionalLight = new THREE.DirectionalLight(0xfff4e6, 1.2);
        directionalLight.position.set(5, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -15;
        directionalLight.shadow.camera.right = 15;
        directionalLight.shadow.camera.top = 15;
        directionalLight.shadow.camera.bottom = -15;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);
        updateProgress();
        
        // Fill light to reduce harsh shadows
        const fillLight = new THREE.DirectionalLight(0x667788, 0.5);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);
        
        // Room dimensions
        const roomWidth = 12;
        const roomHeight = 5;
        const roomDepth = 18;
        
        // Improved floor with PBR materials
        const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
        const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', updateProgress);
        const floorNormalMap = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_normal.jpg', updateProgress);
        const floorRoughnessMap = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_roughness.jpg', updateProgress);
        
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorNormalMap.wrapS = floorNormalMap.wrapT = THREE.RepeatWrapping;
        floorRoughnessMap.wrapS = floorRoughnessMap.wrapT = THREE.RepeatWrapping;
        
        const repeatFactor = 4;
        floorTexture.repeat.set(roomWidth/repeatFactor, roomDepth/repeatFactor);
        floorNormalMap.repeat.set(roomWidth/repeatFactor, roomDepth/repeatFactor);
        floorRoughnessMap.repeat.set(roomWidth/repeatFactor, roomDepth/repeatFactor);
        
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            map: floorTexture,
            normalMap: floorNormalMap,
            roughnessMap: floorRoughnessMap,
            roughness: 0.7,
            metalness: 0.1
        });
        
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.1;
        floor.receiveShadow = true;
        scene.add(floor);
        updateProgress();
        
        // Enhanced walls with improved materials
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf8f8f8,
            roughness: 0.3,
            metalness: 0.05,
            side: THREE.DoubleSide
        });
        
        // Left wall with window
        const leftWallGeometry = new THREE.PlaneGeometry(roomDepth, roomHeight);
        const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.set(-roomWidth/2, roomHeight/2, 0);
        leftWall.receiveShadow = true;
        scene.add(leftWall);
        
        // Create a window in the left wall
        const windowGeometry = new THREE.PlaneGeometry(3, 2);
        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x88ccff,
            transparent: true,
            opacity: 0.3,
            metalness: 0.9,
            roughness: 0.1,
            emissive: 0x88ccff,
            emissiveIntensity: 0.2
        });
        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
        windowMesh.position.set(-roomWidth/2, 2, -4);
        windowMesh.rotation.y = Math.PI / 2;
        scene.add(windowMesh);
        
        // Window frame
        const windowFrameMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.4,
            metalness: 0.2
        });
        
        const windowFrameOuter = new THREE.Mesh(
            new THREE.PlaneGeometry(3.2, 2.2),
            windowFrameMaterial
        );
        windowFrameOuter.position.set(-roomWidth/2, 2, -4);
        windowFrameOuter.rotation.y = Math.PI / 2;
        scene.add(windowFrameOuter);
        
        // Right wall with decorative elements
        const rightWall = new THREE.Mesh(leftWallGeometry.clone(), wallMaterial);
        rightWall.rotation.y = Math.PI / 2;
        rightWall.position.set(roomWidth/2, roomHeight/2, 0);
        rightWall.receiveShadow = true;
        scene.add(rightWall);
        
        // Add wall trim
        const wallTrimGeometry = new THREE.BoxGeometry(roomWidth + 0.2, 0.1, 0.2);
        const wallTrimMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.5 });
        
        const wallTrim1 = new THREE.Mesh(wallTrimGeometry, wallTrimMaterial);
        wallTrim1.position.set(0, 3.8, -roomDepth/2 + 0.1);
        scene.add(wallTrim1);
        
        const wallTrim2 = new THREE.Mesh(wallTrimGeometry, wallTrimMaterial);
        wallTrim2.position.set(0, 3.8, roomDepth/2 - 0.1);
        scene.add(wallTrim2);
        
        // Front wall with door
        const frontWallGeometry = new THREE.PlaneGeometry(roomWidth - 2, roomHeight);
        const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
        frontWall.position.set(-1, roomHeight/2, -roomDepth/2);
        frontWall.receiveShadow = true;
        scene.add(frontWall);
        
        const frontWallRight = new THREE.Mesh(
            new THREE.PlaneGeometry(2, roomHeight),
            wallMaterial
        );
        frontWallRight.position.set(2, roomHeight/2, -roomDepth/2);
        frontWallRight.receiveShadow = true;
        scene.add(frontWallRight);
        
        // Door
        const doorGeometry = new THREE.PlaneGeometry(2, 3);
        const doorMaterial = new THREE.MeshStandardMaterial({
            color: 0x5c3a21,
            roughness: 0.6,
            metalness: 0.1
        });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.position.set(1, 1.5, -roomDepth/2 + 0.01);
        door.castShadow = true;
        scene.add(door);
        
        // Door frame
        const doorFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2a1a });
        const doorFrameVertical = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 3.2, 0.1),
            doorFrameMaterial
        );
        doorFrameVertical.position.set(0, 1.5, -roomDepth/2 + 0.05);
        scene.add(doorFrameVertical);
        
        const doorFrameHorizontal = new THREE.Mesh(
            new THREE.BoxGeometry(2.2, 0.1, 0.1),
            doorFrameMaterial
        );
        doorFrameHorizontal.position.set(1, 3.1, -roomDepth/2 + 0.05);
        scene.add(doorFrameHorizontal);
        
        // Back wall with shelves
        const backWall = new THREE.Mesh(frontWallGeometry.clone(), wallMaterial);
        backWall.position.set(0, roomHeight/2, roomDepth/2);
        backWall.receiveShadow = true;
        scene.add(backWall);
        
        // Ceiling with light fixtures
        const ceilingMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf0f0f0,
            roughness: 0.5,
            metalness: 0.0
        });
        
        const ceiling = new THREE.Mesh(
            new THREE.PlaneGeometry(roomWidth, roomDepth),
            ceilingMaterial
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = roomHeight;
        ceiling.receiveShadow = true;
        scene.add(ceiling);
        
        // Add ceiling lights
        function createCeilingLight(x, z) {
            const lightGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            const lightMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5,
                roughness: 0.1,
                metalness: 0.8
            });
            
            const lightFixture = new THREE.Mesh(lightGeometry, lightMaterial);
            lightFixture.position.set(x, roomHeight - 0.05, z);
            lightFixture.rotation.x = Math.PI / 2;
            scene.add(lightFixture);
            
            const pointLight = new THREE.PointLight(0xffffee, 1.5, 8, 2);
            pointLight.position.set(x, roomHeight - 0.5, z);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 1024;
            pointLight.shadow.mapSize.height = 1024;
            scene.add(pointLight);
            
            return lightFixture;
        }
        
        createCeilingLight(-3, -5);
        createCeilingLight(3, -5);
        createCeilingLight(-3, 5);
        createCeilingLight(3, 5);
        updateProgress();
        
        // Enhanced furniture with more details
        function createTable(x, z, rotation = 0) {
            // Table top with better wood texture
            const tableTopGeometry = new THREE.BoxGeometry(2, 0.08, 1);
            const tableTopTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/wood_diffuse.jpg', updateProgress);
            tableTopTexture.wrapS = tableTopTexture.wrapT = THREE.RepeatWrapping;
            tableTopTexture.repeat.set(2, 1);
            
            const tableTopMaterial = new THREE.MeshStandardMaterial({ 
                map: tableTopTexture,
                roughness: 0.6,
                metalness: 0.1,
                normalMap: new THREE.TextureLoader().load('https://threejs.org/examples/textures/wood_normal.jpg', updateProgress),
                normalScale: new THREE.Vector2(0.5, 0.5)
            });
            
            const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
            tableTop.position.set(x, 0.7, z);
            tableTop.rotation.y = rotation;
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            scene.add(tableTop);
            
            // Table legs with metal caps
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 16);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.4,
                metalness: 0.8
            });
            
            const legPositions = [
                [x - 0.9, 0.35, z - 0.4],
                [x - 0.9, 0.35, z + 0.4],
                [x + 0.9, 0.35, z - 0.4],
                [x + 0.9, 0.35, z + 0.4]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.castShadow = true;
                leg.receiveShadow = true;
                scene.add(leg);
                
                // Leg cap
                const capGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.02, 16);
                const capMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa,
                    roughness: 0.2,
                    metalness: 0.9
                });
                
                const topCap = new THREE.Mesh(capGeometry, capMaterial);
                topCap.position.set(pos[0], pos[1] + 0.36, pos[2]);
                scene.add(topCap);
                
                const bottomCap = new THREE.Mesh(capGeometry, capMaterial);
                bottomCap.position.set(pos[0], pos[1] - 0.36, pos[2]);
                scene.add(bottomCap);
            });
            
            return tableTop;
        }
        
        function createChair(x, z, rotationY) {
            // Chair seat with cushion
            const seatGeometry = new THREE.BoxGeometry(0.6, 0.08, 0.6);
            const seatMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.5,
                metalness: 0.0
            });
            
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(x, 0.4, z);
            seat.rotation.y = rotationY;
            seat.castShadow = true;
            seat.receiveShadow = true;
            scene.add(seat);
            
            // Cushion
            const cushionGeometry = new THREE.BoxGeometry(0.55, 0.1, 0.55);
            const cushionMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b5a2b,
                roughness: 0.8,
                metalness: 0.0
            });
            
            const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
            cushion.position.set(x, 0.45, z);
            cushion.rotation.y = rotationY;
            cushion.castShadow = true;
            cushion.receiveShadow = true;
            scene.add(cushion);
            
            // Chair legs
            const chairLegGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.4,
                metalness: 0.8
            });
            
            const legPositions = [
                [x - 0.25, 0.2, z - 0.25],
                [x - 0.25, 0.2, z + 0.25],
                [x + 0.25, 0.2, z - 0.25],
                [x + 0.25, 0.2, z + 0.25]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(chairLegGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.rotation.y = rotationY;
                leg.castShadow = true;
                leg.receiveShadow = true;
                scene.add(leg);
            });
            
            // Chair back with slats
            const backGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.04);
            const backMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.5,
                metalness: 0.0
            });
            
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(
                x, 
                0.65, 
                z + (rotationY === 0 ? 0.3 : -0.3)
            );
            back.rotation.y = rotationY;
            back.castShadow = true;
            back.receiveShadow = true;
            scene.add(back);
            
            // Back slats
            for (let i = 0; i < 3; i++) {
                const slatGeometry = new THREE.BoxGeometry(0.45, 0.05, 0.02);
                const slat = new THREE.Mesh(slatGeometry, backMaterial);
                slat.position.set(
                    x,
                    0.55 + i * 0.15,
                    z + (rotationY === 0 ? 0.32 : -0.32)
                );
                slat.rotation.y = rotationY;
                slat.castShadow = true;
                scene.add(slat);
            }
            
            return seat;
        }
        
        // Create tables and chairs with more variety
        const mainTable = createTable(0, -4);
        createChair(-0.8, -4.8, 0);
        createChair(0.8, -4.8, 0);
        createChair(0, -3.2, Math.PI);
        
        const leftTable = createTable(-3, 2, Math.PI/4);
        createChair(-3.8, 1.2, Math.PI/2);
        createChair(-3.8, 2.8, Math.PI/2);
        createChair(-2.2, 2, -Math.PI/2);
        
        const rightTable = createTable(3, 2, -Math.PI/4);
        createChair(3.8, 1.2, -Math.PI/2);
        createChair(3.8, 2.8, -Math.PI/2);
        createChair(2.2, 2, Math.PI/2);
        updateProgress();
        
        // Enhanced rug with fringe
        const rugGeometry = new THREE.PlaneGeometry(6, 4);
        const rugTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/carpet.jpg', updateProgress);
        rugTexture.wrapS = THREE.RepeatWrapping;
        rugTexture.wrapT = THREE.RepeatWrapping;
        rugTexture.repeat.set(2, 2);
        
        const rugMaterial = new THREE.MeshStandardMaterial({ 
            map: rugTexture,
            roughness: 0.9,
            metalness: 0.0,
            displacementMap: rugTexture,
            displacementScale: 0.01
        });
        
        const rug = new THREE.Mesh(rugGeometry, rugMaterial);
        rug.rotation.x = -Math.PI / 2;
        rug.position.set(0, 0.01, 0);
        rug.receiveShadow = true;
        scene.add(rug);
        
        // Rug fringe
        const fringeGeometry = new THREE.CylinderGeometry(3.02, 3.02, 0.1, 64, 1, true);
        const fringeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            roughness: 0.9,
            side: THREE.DoubleSide
        });
        
        const fringe = new THREE.Mesh(fringeGeometry, fringeMaterial);
        fringe.rotation.x = Math.PI / 2;
        fringe.position.set(0, 0.01, 0);
        scene.add(fringe);
        
        // Enhanced painting with frame
        const paintingGeometry = new THREE.PlaneGeometry(2.5, 1.8);
        const paintingTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/painting.jpg', updateProgress);
        const paintingMaterial = new THREE.MeshStandardMaterial({ 
            map: paintingTexture,
            roughness: 0.2,
            metalness: 0.0
        });
        
        const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
        painting.position.set(0, 2, -roomDepth/2 + 0.01);
        scene.add(painting);
        
        // Painting frame
        const frameGeometry = new THREE.BoxGeometry(2.6, 1.9, 0.1);
        const frameOuter = new THREE.Mesh(
            frameGeometry,
            new THREE.MeshStandardMaterial({
                color: 0x5c3a21,
                roughness: 0.4,
                metalness: 0.3
            })
        );
        frameOuter.position.set(0, 2, -roomDepth/2 + 0.06);
        scene.add(frameOuter);
        
        const frameInnerGeometry = new THREE.BoxGeometry(2.55, 1.85, 0.11);
        const frameInner = new THREE.Mesh(
            frameInnerGeometry,
            new THREE.MeshStandardMaterial({
                color: 0xd4a76a,
                roughness: 0.3,
                metalness: 0.5
            })
        );
        frameInner.position.set(0, 2, -roomDepth/2 + 0.055);
        scene.add(frameInner);
        
        // Decorative lamp with more details
        function createLamp(x, z) {
            // Lamp base
            const lampBaseGeometry = new THREE.CylinderGeometry(0.15, 0.25, 0.2, 32);
            const lampBaseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.3,
                metalness: 0.9
            });
            const lampBase = new THREE.Mesh(lampBaseGeometry, lampBaseMaterial);
            lampBase.position.set(x, 0.1, z);
            lampBase.castShadow = true;
            scene.add(lampBase);
            
            // Lamp pole
            const lampPoleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.5, 32);
            const lampPoleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.2,
                metalness: 0.9
            });
            const lampPole = new THREE.Mesh(lampPoleGeometry, lampPoleMaterial);
            lampPole.position.set(x, 1, z);
            lampPole.castShadow = true;
            scene.add(lampPole);
            
            // Lamp shade with fabric texture
            const lampShadeGeometry = new THREE.ConeGeometry(0.5, 0.3, 32);
            const lampShadeTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/fabric.jpg', updateProgress);
            lampShadeTexture.wrapS = THREE.RepeatWrapping;
            lampShadeTexture.wrapT = THREE.RepeatWrapping;
            lampShadeTexture.repeat.set(2, 2);
            
            const lampShadeMaterial = new THREE.MeshStandardMaterial({ 
                map: lampShadeTexture,
                roughness: 0.8,
                metalness: 0.0,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const lampShade = new THREE.Mesh(lampShadeGeometry, lampShadeMaterial);
            lampShade.position.set(x, 1.5, z);
            lampShade.rotation.x = Math.PI;
            lampShade.castShadow = true;
            scene.add(lampShade);
            
            // Lamp light with warmer color
            const lampLight = new THREE.PointLight(0xffddbb, 2, 6, 2);
            lampLight.position.set(x, 1.3, z);
            lampLight.castShadow = true;
            lampLight.shadow.mapSize.width = 1024;
            lampLight.shadow.mapSize.height = 1024;
            scene.add(lampLight);
            
            // Light bulb
            const bulbGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const bulbMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffcc,
                emissive: 0xffffaa,
                emissiveIntensity: 0.5,
                roughness: 0.1,
                metalness: 0.0
            });
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(x, 1.3, z);
            scene.add(bulb);
            
            return lampBase;
        }
        
        const lamp1 = createLamp(0, 0);
        const lamp2 = createLamp(-4, 5);
        const lamp3 = createLamp(4, 5);
        updateProgress();
        
        // Add plants for decoration
        function createPlant(x, z, size = 1) {
            const potGeometry = new THREE.CylinderGeometry(0.3 * size, 0.4 * size, 0.4 * size, 32);
            const potMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513,
                roughness: 0.7,
                metalness: 0.1
            });
            const pot = new THREE.Mesh(potGeometry, potMaterial);
            pot.position.set(x, 0.2 * size, z);
            pot.castShadow = true;
            scene.add(pot);
            
            // Plant leaves
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a5f0b,
                roughness: 0.9,
                metalness: 0.0
            });
            
            for (let i = 0; i < 5; i++) {
                const leafGeometry = new THREE.SphereGeometry(0.3 * size, 8, 8);
                const leaf = new THREE.Mesh(leafGeometry, leavesMaterial);
                leaf.position.set(
                    x + (Math.random() - 0.5) * 0.3,
                    0.5 * size + i * 0.2,
                    z + (Math.random() - 0.5) * 0.3
                );
                leaf.castShadow = true;
                scene.add(leaf);
            }
            
            return pot;
        }
        
        createPlant(-4, -5, 0.8);
        createPlant(4, -5, 0.8);
        createPlant(-5, 0, 1.2);
        createPlant(5, 0, 1.2);
        
        // Add books on tables
        function createBooks(x, z, count = 3) {
            const bookColors = [
                0x8b0000, 0x006400, 0x00008b, 0x4b0082, 
                0x8b4513, 0x2f4f4f, 0x8b008b, 0x556b2f
            ];
            
            for (let i = 0; i < count; i++) {
                const bookWidth = 0.15 + Math.random() * 0.05;
                const bookHeight = 0.02 + Math.random() * 0.01;
                const bookDepth = 0.2 + Math.random() * 0.1;
                
                const bookGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth);
                const bookMaterial = new THREE.MeshStandardMaterial({
                    color: bookColors[Math.floor(Math.random() * bookColors.length)],
                    roughness: 0.6,
                    metalness: 0.0
                });
                
                const book = new THREE.Mesh(bookGeometry, bookMaterial);
                book.position.set(
                    x + (Math.random() - 0.5) * 0.5,
                    0.74 + i * bookHeight * 1.1,
                    z + (Math.random() - 0.5) * 0.3
                );
                
                // Random rotation
                book.rotation.y = Math.random() * Math.PI * 2;
                book.rotation.z = (Math.random() - 0.5) * 0.2;
                
                book.castShadow = true;
                scene.add(book);
            }
        }
        
        createBooks(0, -4, 5);
        createBooks(-3, 2, 3);
        createBooks(3, 2, 3);
        
        // Add a clock on the wall
        function createClock(x, y, z) {
            // Clock face
            const clockGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.05, 32);
            const clockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                roughness: 0.3,
                metalness: 0.2
            });
            const clock = new THREE.Mesh(clockGeometry, clockMaterial);
            clock.position.set(x, y, z);
            clock.rotation.x = Math.PI / 2;
            scene.add(clock);
            
            // Clock frame
            const frameGeometry = new THREE.TorusGeometry(0.8, 0.03, 16, 32);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.4,
                metalness: 0.7
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(x, y, z);
            frame.rotation.x = Math.PI / 2;
            scene.add(frame);
            
            // Clock numbers (simplified)
            const numberMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            for (let i = 1; i <= 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const numberGeometry = new THREE.BoxGeometry(0.05, 0.1, 0.01);
                const number = new THREE.Mesh(numberGeometry, numberMaterial);
                number.position.set(
                    x + Math.sin(angle) * 0.7,
                    y + Math.cos(angle) * 0.7,
                    z + 0.03
                );
                number.rotation.z = -angle;
                scene.add(number);
            }
            
            // Clock hands
            const hourHandGeometry = new THREE.BoxGeometry(0.04, 0.4, 0.01);
            const hourHand = new THREE.Mesh(hourHandGeometry, numberMaterial);
            hourHand.position.set(x, y, z + 0.04);
            scene.add(hourHand);
            
            const minuteHandGeometry = new THREE.BoxGeometry(0.03, 0.6, 0.01);
            const minuteHand = new THREE.Mesh(minuteHandGeometry, numberMaterial);
            minuteHand.position.set(x, y - 0.1, z + 0.05);
            minuteHand.rotation.z = -Math.PI / 6;
            scene.add(minuteHand);
            
            const secondHandGeometry = new THREE.BoxGeometry(0.01, 0.7, 0.005);
            const secondHandMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const secondHand = new THREE.Mesh(secondHandGeometry, secondHandMaterial);
            secondHand.position.set(x, y - 0.15, z + 0.06);
            secondHand.rotation.z = -Math.PI / 3;
            scene.add(secondHand);
            
            // Center cap
            const capGeometry = new THREE.SphereGeometry(0.03, 16, 16);
            const capMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.2,
                metalness: 0.9
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.set(x, y, z + 0.07);
            scene.add(cap);
            
            return clock;
        }
        
        createClock(0, 3.5, roomDepth/2 - 0.1);
        updateProgress();
        
        // Improved player controls with more features
        const controls = new THREE.FirstPersonControls(camera, renderer.domElement);
        controls.movementSpeed = 4;
        controls.lookSpeed = 0.08;
        controls.lookVertical = true;
        controls.constrainVertical = true;
        controls.verticalMin = 1.0;
        controls.verticalMax = 2.2;
        controls.activeLook = true;
        
        // Add sprinting
        let isSprinting = false;
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') {
                isSprinting = true;
                controls.movementSpeed = 8;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                isSprinting = false;
                controls.movementSpeed = 4;
            }
        });
        
        // Add jumping
        let velocityY = 0;
        let isGrounded = true;
        const gravity = -9.8;
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && isGrounded) {
                velocityY = 5;
                isGrounded = false;
            }
        });
        
        // Enhanced collision detection with furniture
        const roomBounds = {
            minX: -roomWidth/2 + 0.5,
            maxX: roomWidth/2 - 0.5,
            minZ: -roomDepth/2 + 0.5,
            maxZ: roomDepth/2 - 0.5,
            minY: 0,
            maxY: roomHeight - 0.5
        };
        
        const furniture = [
            { position: [0, 0, -4], size: [2, 1, 1], type: 'table' },
            { position: [-3, 0, 2], size: [2, 1, 1], type: 'table' },
            { position: [3, 0, 2], size: [2, 1, 1], type: 'table' },
            { position: [0, 0, 0], size: [6, 0.1, 4], type: 'rug' },
            { position: [-4, 0, 5], size: [0.8, 1, 0.8], type: 'lamp' },
            { position: [4, 0, 5], size: [0.8, 1, 0.8], type: 'lamp' },
            { position: [0, 0, roomDepth/2 - 0.1], size: [1.6, 1.6, 0.2], type: 'clock' }
        ];
        
        function checkCollision(newPosition) {
            // Check room bounds
            if (newPosition.x < roomBounds.minX || newPosition.x > roomBounds.maxX ||
                newPosition.z < roomBounds.minZ || newPosition.z > roomBounds.maxZ ||
                newPosition.y < roomBounds.minY || newPosition.y > roomBounds.maxY) {
                return true;
            }
            
            // Check furniture collision
            for (const item of furniture) {
                if (item.type === 'rug') continue; // Skip rug for collision
                
                const halfSizeX = item.size[0] / 2;
                const halfSizeZ = item.size[2] / 2;
                const halfSizeY = item.size[1] / 2;
                
                // Check XZ collision
                if (Math.abs(newPosition.x - item.position[0]) < halfSizeX + 0.5 &&
                    Math.abs(newPosition.z - item.position[2]) < halfSizeZ + 0.5) {
                    
                    // Check Y collision only if we're not jumping over it
                    if (newPosition.y < item.position[1] + halfSizeY + 1.6 && 
                        newPosition.y > item.position[1] - halfSizeY) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Override controls movement for collision detection
        const originalMoveMethod = controls.move;
        controls.move = function(delta) {
            const oldPosition = this.object.position.clone();
            originalMoveMethod.call(this, delta);
            
            // Apply gravity
            velocityY += gravity * delta;
            this.object.position.y += velocityY * delta;
            
            // Ground collision
            if (this.object.position.y < 1.6) {
                this.object.position.y = 1.6;
                velocityY = 0;
                isGrounded = true;
            }
            
            if (checkCollision(this.object.position)) {
                this.object.position.copy(oldPosition);
            }
        };
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            controls.handleResize();
            
            // Update FXAA resolution
            fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Animation loop with time-based updates
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Calculate delta time in seconds
            const deltaTime = Math.min(0.1, (time - lastTime) / 1000);
            lastTime = time;
            
            // Update controls
            controls.update(deltaTime);
            
            // Update post-processing
            composer.render();
            
            // Make clock hands move
            const clock = scene.getObjectByName('clock');
            if (clock) {
                const seconds = time / 1000;
                const hourHand = clock.children.find(c => c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.04);
                const minuteHand = clock.children.find(c => c.geometry instanceof THREE.BoxGeometry && c.geometry.parameters.width === 0.03);
                const secondHand = clock.children.find(c => c.material.color.getHex() === 0xff0000);
                
                if (hourHand && minuteHand && secondHand) {
                    hourHand.rotation.z = -((seconds % 43200) / 43200) * Math.PI * 2;
                    minuteHand.rotation.z = -((seconds % 3600) / 3600) * Math.PI * 2;
                    secondHand.rotation.z = -((seconds % 60) / 60) * Math.PI * 2;
                }
            }
        }
        
        // Start animation
        animate(0);
        
        // Final asset loaded
        updateProgress();
    </script>
</body>
</html>
