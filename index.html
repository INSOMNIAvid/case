<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Room Walkthrough</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">3D Room Walkthrough<br>WASD: Move | SPACE: Jump | Mouse: Look around</div>
    <div id="controls">WASD: Move | SPACE: Jump | Mouse: Look around</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/FirstPersonControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/FXAAShader.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.002);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        // Renderer with antialiasing and higher quality settings
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const outlinePass = new THREE.OutlinePass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            scene,
            camera
        );
        outlinePass.edgeStrength = 3.0;
        outlinePass.edgeGlow = 0.5;
        outlinePass.edgeThickness = 1.0;
        outlinePass.pulsePeriod = 0;
        outlinePass.visibleEdgeColor.set('#ffffff');
        outlinePass.hiddenEdgeColor.set('#190a05');
        composer.addPass(outlinePass);

        const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        fxaaPass.material.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        composer.addPass(fxaaPass);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffaa00, 1, 10);
        pointLight.position.set(0, 2.5, 0);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 1024;
        pointLight.shadow.mapSize.height = 1024;
        scene.add(pointLight);

        // Room dimensions
        const roomWidth = 10;
        const roomHeight = 4;
        const roomDepth = 15;

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
        const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(roomWidth/3, roomDepth/3);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            map: floorTexture,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.1;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf0f0f0,
            roughness: 0.4,
            metalness: 0.1
        });

        // Left wall
        const leftWallGeometry = new THREE.PlaneGeometry(roomDepth, roomHeight);
        const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.set(-roomWidth/2, roomHeight/2, 0);
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        // Right wall
        const rightWall = new THREE.Mesh(leftWallGeometry.clone(), wallMaterial);
        rightWall.rotation.y = Math.PI / 2;
        rightWall.position.set(roomWidth/2, roomHeight/2, 0);
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Front wall
        const frontWallGeometry = new THREE.PlaneGeometry(roomWidth, roomHeight);
        const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
        frontWall.position.set(0, roomHeight/2, -roomDepth/2);
        frontWall.receiveShadow = true;
        scene.add(frontWall);

        // Back wall
        const backWall = new THREE.Mesh(frontWallGeometry.clone(), wallMaterial);
        backWall.position.set(0, roomHeight/2, roomDepth/2);
        backWall.receiveShadow = true;
        scene.add(backWall);

        // Ceiling
        const ceiling = new THREE.Mesh(floorGeometry.clone(), new THREE.MeshStandardMaterial({ 
            color: 0xe0e0e0,
            roughness: 0.6,
            metalness: 0.0
        }));
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = roomHeight;
        ceiling.receiveShadow = true;
        scene.add(ceiling);

        // Add some furniture
        function createTable(x, z) {
            // Table top
            const tableTopGeometry = new THREE.BoxGeometry(2, 0.1, 1);
            const tableTopMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.1
            });
            const tableTop = new THREE.Mesh(tableTopGeometry, tableTopMaterial);
            tableTop.position.set(x, 0.7, z);
            tableTop.castShadow = true;
            tableTop.receiveShadow = true;
            scene.add(tableTop);

            // Table legs
            const legGeometry = new THREE.BoxGeometry(0.1, 0.7, 0.1);
            const legPositions = [
                [x - 0.9, 0.35, z - 0.4],
                [x - 0.9, 0.35, z + 0.4],
                [x + 0.9, 0.35, z - 0.4],
                [x + 0.9, 0.35, z + 0.4]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, tableTopMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.castShadow = true;
                leg.receiveShadow = true;
                scene.add(leg);
            });

            return tableTop;
        }

        function createChair(x, z, rotationY) {
            // Chair seat
            const seatGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.6);
            const seatMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.6,
                metalness: 0.0
            });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(x, 0.4, z);
            seat.rotation.y = rotationY;
            seat.castShadow = true;
            seat.receiveShadow = true;
            scene.add(seat);

            // Chair legs
            const chairLegGeometry = new THREE.BoxGeometry(0.05, 0.4, 0.05);
            const legPositions = [
                [x - 0.25, 0.2, z - 0.25],
                [x - 0.25, 0.2, z + 0.25],
                [x + 0.25, 0.2, z - 0.25],
                [x + 0.25, 0.2, z + 0.25]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(chairLegGeometry, seatMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.rotation.y = rotationY;
                leg.castShadow = true;
                leg.receiveShadow = true;
                scene.add(leg);
            });

            // Chair back
            const backGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.05);
            const back = new THREE.Mesh(backGeometry, seatMaterial);
            back.position.set(x, 0.65, z + (rotationY === 0 ? 0.3 : -0.3));
            back.rotation.y = rotationY;
            back.castShadow = true;
            back.receiveShadow = true;
            scene.add(back);

            return seat;
        }

        // Create tables and chairs
        createTable(0, -4);
        createChair(-0.8, -4.8, 0);
        createChair(0.8, -4.8, 0);
        createChair(0, -3.2, Math.PI);

        createTable(-3, 2);
        createChair(-3.8, 1.2, Math.PI/2);
        createChair(-3.8, 2.8, Math.PI/2);
        createChair(-2.2, 2, -Math.PI/2);

        createTable(3, 2);
        createChair(3.8, 1.2, -Math.PI/2);
        createChair(3.8, 2.8, -Math.PI/2);
        createChair(2.2, 2, Math.PI/2);

        // Add a rug
        const rugGeometry = new THREE.PlaneGeometry(6, 4);
        const rugTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/carpet.jpg');
        rugTexture.wrapS = THREE.RepeatWrapping;
        rugTexture.wrapT = THREE.RepeatWrapping;
        rugTexture.repeat.set(2, 2);
        const rugMaterial = new THREE.MeshStandardMaterial({ 
            map: rugTexture,
            roughness: 0.9,
            metalness: 0.0
        });
        const rug = new THREE.Mesh(rugGeometry, rugMaterial);
        rug.rotation.x = -Math.PI / 2;
        rug.position.set(0, 0.01, 0);
        rug.receiveShadow = true;
        scene.add(rug);

        // Add a painting on the wall
        const paintingGeometry = new THREE.PlaneGeometry(2, 1.5);
        const paintingTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/painting.jpg');
        const paintingMaterial = new THREE.MeshStandardMaterial({ 
            map: paintingTexture,
            roughness: 0.2,
            metalness: 0.0
        });
        const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
        painting.position.set(0, 2, -roomDepth/2 + 0.01);
        scene.add(painting);

        // Add a lamp
        const lampBaseGeometry = new THREE.CylinderGeometry(0.1, 0.2, 0.2, 32);
        const lampBaseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x888888,
            roughness: 0.3,
            metalness: 0.8
        });
        const lampBase = new THREE.Mesh(lampBaseGeometry, lampBaseMaterial);
        lampBase.position.set(0, 0.1, 0);
        lampBase.castShadow = true;
        scene.add(lampBase);

        const lampPoleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 32);
        const lampPole = new THREE.Mesh(lampPoleGeometry, lampBaseMaterial);
        lampPole.position.set(0, 1, 0);
        lampPole.castShadow = true;
        scene.add(lampPole);

        const lampShadeGeometry = new THREE.ConeGeometry(0.5, 0.3, 32);
        const lampShadeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            roughness: 0.7,
            metalness: 0.0,
            transparent: true,
            opacity: 0.7
        });
        const lampShade = new THREE.Mesh(lampShadeGeometry, lampShadeMaterial);
        lampShade.position.set(0, 1.5, 0);
        lampShade.rotation.x = Math.PI;
        lampShade.castShadow = true;
        scene.add(lampShade);

        // Add a point light inside the lamp
        const lampLight = new THREE.PointLight(0xffeedd, 1, 5);
        lampLight.position.set(0, 1.3, 0);
        lampLight.castShadow = true;
        scene.add(lampLight);

        // Player controls
        const controls = new THREE.FirstPersonControls(camera, renderer.domElement);
        controls.movementSpeed = 5;
        controls.lookSpeed = 0.1;
        controls.lookVertical = true;
        controls.constrainVertical = true;
        controls.verticalMin = 1.0;
        controls.verticalMax = 2.0;

        // Collision detection
        const roomBounds = {
            minX: -roomWidth/2 + 0.5,
            maxX: roomWidth/2 - 0.5,
            minZ: -roomDepth/2 + 0.5,
            maxZ: roomDepth/2 - 0.5,
            minY: 0,
            maxY: roomHeight - 0.5
        };

        const furniture = [
            { position: [0, 0, -4], size: [2, 1, 1] }, // Table 1
            { position: [-3, 0, 2], size: [2, 1, 1] }, // Table 2
            { position: [3, 0, 2], size: [2, 1, 1] },  // Table 3
            { position: [0, 0, 0], size: [6, 0.1, 4] }  // Rug (not blocking but for demo)
        ];

        function checkCollision(newPosition) {
            // Check room bounds
            if (newPosition.x < roomBounds.minX || newPosition.x > roomBounds.maxX ||
                newPosition.z < roomBounds.minZ || newPosition.z > roomBounds.maxZ) {
                return true;
            }

            // Check furniture collision (simplified)
            for (const item of furniture) {
                const halfSizeX = item.size[0] / 2;
                const halfSizeZ = item.size[2] / 2;
                
                if (Math.abs(newPosition.x - item.position[0]) < halfSizeX + 0.5 &&
                    Math.abs(newPosition.z - item.position[2]) < halfSizeZ + 0.5) {
                    return true;
                }
            }

            return false;
        }

        const originalMoveMethod = controls.move;
        controls.move = function(delta) {
            const oldPosition = this.object.position.clone();
            originalMoveMethod.call(this, delta);
            
            if (checkCollision(this.object.position)) {
                this.object.position.copy(oldPosition);
            }
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            controls.handleResize();
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(0.016); // Assume 60fps
            composer.render();
        }

        animate();
    </script>
</body>
</html>